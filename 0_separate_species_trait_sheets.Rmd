---
title: "Process species trait spreadsheets"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

source('https://raw.githubusercontent.com/oharac/src/master/R/common.R')

```

# Summary

Read in Excel spreadsheets of taxonomic traits filled in by taxon experts.  Process into a long/tidy format with checks on validity of category values.  Identify categories that were assigned non-valid values.

# Data

`_raw_data/all_taxa_trait_data.xlsx' is the raw spreadsheet prepared by Nathalie Butt from the various submissions of the taxa-group experts.  Basic format:

Columns `category`, `sub-category`, and `category units` are standard.  Additional columns correspond to species or species groups, with perhaps additional idiosyncratic columns populated with totals, notes, comments, etc.

# Methods

Set up cleaner functions

```{r}
clean_up_mess <- function(df) {
  df %>%
    mutate(trait_val_clean = str_trim(trait_val_clean)) %>%
    filter(trait_val_clean != '') %>%
    select(category, trait, trait_value, trait_val_clean, spp_gp, sheet) %>%
    distinct()
}

clean_trait <- function(x) {
  ### First: remove numeric commas
  y <- str_replace_all(x, '(?<=[0-9]),(?=[0-9])', '') %>%
    ### then: drop all non-alphanumeric and a few key punctuation:
    str_replace_all('[^0-9a-zA-Z<>,;\\-\\.\\(\\)/ ]', '') %>% 
    ### lower case; do it after dropping any weird non-ascii characters:
    tolower() %>% 
    str_trim() %>%
    str_replace_all('n/a', 'na') %>%
    ### convert remaining commas and slashes to semicolons:
    str_replace_all('[,/]', ';') %>%
    ### drop spaces after numbers e.g. 3 mm -> 3mm:
    str_replace_all('(?<=[0-9]) ', '') %>%
    ### drop spaces before or after punctuation (non-alphanumeric):
    str_replace_all(' (?=[^a-z0-9\\(])|(?<=[^a-z0-9\\)]) ', '') %>%
    ### manually fix some valid slashes:
    str_replace_all('nearly sessile;sedentary', 'nearly sessile/sedentary') %>%
    str_replace_all('live birth;egg care', 'live birth/egg care') %>%
    str_replace_all('chitin;caco3mix', 'chitin/caco3 mix')
    
  return(y)
}
```

Process Nat's key to create a final key

```{r}
traitvals_df_raw <- readxl::read_excel(here('_raw_data/xlsx/cat_val_key_tidyish.xlsx')) %>%
  janitor::clean_names() %>%
  select(category, trait, trait_value = cat_vals) %>%
  filter(!(is.na(category) & is.na(trait))) %>%
  fill(category, .direction = 'down') %>%
  mutate(category = tolower(category), 
         trait = tolower(trait),
         trait_value = clean_trait(trait_value))
  

traitvals_df_prehabs <- traitvals_df_raw %>%
  mutate(trait_value = str_split(trait_value, pattern = ';')) %>%
  unnest(trait_value) %>%
  ### trim whitespace, replace the temporary slash fixes
  mutate(trait_value = str_trim(trait_value)) %>%
           ### undo the temp slash fix
  filter(!is.na(trait_value)) %>%
  filter(trait_value != '')

### Read in the first column of habitats from the list.  Paste together with
### semicolon separator.  Set to lower case.
habs <- readxl::read_excel(here('_raw_data/xlsx/hab_list.xlsx')) %>%
  janitor::clean_names() %>%
  .$habitat_types %>%
  tolower() %>%
  paste(collapse = ';')
    
### Separate out habitat rows, attach valid habitats, bind back to original.
traitvals_hab <- traitvals_df_prehabs %>%
  filter(str_detect(trait_value, 'habitat')) %>%
  mutate(trait_value = habs,
         trait_value = str_split(habs, pattern = ';')) %>%
  unnest(trait_value)
  

traitvals_df_valid <- traitvals_df_prehabs %>%
  filter(!str_detect(trait_value, 'habitat')) %>%
  bind_rows(traitvals_hab) %>%
  rename(trait_value = trait_value)

write_csv(traitvals_df_valid, '_data/trait_vals_valid.csv')
```

Read in Excel sheets one at a time, convert to long format, bind into a single dataframe with minimal processing.

Set up path and sheetnames

```{r}
raw_file <- here('_raw_data/xlsx/master_all_taxa_trait_data.xlsx')

sheetnames <- readxl::excel_sheets(raw_file)
```

First, check headers to make sure there's not taxonomic information in multiple rows.  The first row of each sheet should be blank, as most sheets have a space before the first category ("Movement").  Even without this space, "Movement" should not have any values of its own, so still blank.

```{r}
check_headers <- function(f, s) {
  ### s <- sheetnames[5]; f <- raw_file
  df <- readxl::read_excel(path = f, sheet = s, n_max = 1) %>%
    gather(hdg, val, -c(1:3)) %>%
    select(hdg, val) %>%
    mutate(sheet = s,
           hdg = as.character(hdg),
           val = as.character(val))
  return(df)
}

hdr_check <- lapply(sheetnames, FUN = function(s) check_headers(raw_file, s)) %>%
  bind_rows() %>%
  filter(!is.na(val))

extras <- hdr_check$sheet %>% unique()
```


``` {r}
process_sheet <- function(f, s) {
  ### f <- raw_file; s <- sheetnames[10]
  df_raw <- readxl::read_excel(path = f, sheet = s)
  
  ### read in to get "valid" categories
  categories <- read_csv('_data/trait_vals_valid.csv') %>%
    .$category %>% unique()
  
  ### this should no longer be necessary - spp traits xlsx is fixed
  # swap_colnames <- c('cephalopods' = 1, 'reef_other_fish' = 1, 'molluscs' = 1, 'fish_Beth' = 2)
  # if(s %in% names(swap_colnames)) {
  #   ### problematic spp sheets - taxonomic info in second line of csv
  #   spp_names <- df_raw[swap_colnames[s], ] %>% as.character()
  #   spp_names[1:3] <- c('category', 'sub_category', 'category units')
  #   df_raw <- df_raw %>%
  #     setNames(spp_names)
  # }
    
  df <- df_raw %>%
    gather(spp_gp, trait_value, -c(1:3)) %>%
    janitor::clean_names() %>%
    select(-category_units)
  
  df_cleaned <- df %>%
    mutate(trait = ifelse(is.na(sub_category), category, sub_category),
           trait = tolower(trait),
           category = tolower(category),
           category = ifelse(category == 'light dependence', 'specialisation', category),
             ### fill in below the "physiological tolerance breadths" category
           category = ifelse(!category %in% categories, NA, category)) %>%
    fill(category, .direction = 'down') %>%
    select(category, trait, spp_gp, trait_value) %>%
    filter(!is.na(trait)) %>%
      ### drops rows with no trait listed
    filter(trait != category) %>%
      ### drops category headings in the traits column
    mutate(sheet = s)
  
  return(df_cleaned)
}


raw_data_df <- lapply(sheetnames, FUN = function(s) process_sheet(raw_file, s)) %>%
  bind_rows() %>%
  ### fix typos and minor fixes:
  mutate(trait_value = str_replace_all(trait_value, 'demerssal', 'demersal'),
         trait_value = str_replace_all(trait_value, 'esturary', 'estuary'),
         trait_value = str_replace_all(trait_value, 'interntidal', 'intertidal'),
         trait_value = str_replace_all(trait_value, 'lentgh', 'length'),
         trait_value = str_replace_all(trait_value, 'this sp,', 'this sp.'),
         trait = str_replace_all(trait, '\\(pld\\)$', '(pld) exposure'))

```

Check raw data against valid category values.

* Set all values to lower case to avoid case sensitivity.
* replace "n/a" with "na"
* Ditch numeric commas.
* Split trait values on semicolons to separate multiple cell values; then unnest and str_trim.


### clean up troublesome traits

```{r clean up zone traits}
traitvals_df_clean <- read_csv('_data/trait_vals_valid.csv') %>%
  mutate(cat_val_clean = clean_trait(trait_value))

zone_vals <- traitvals_df_valid %>%
  filter(trait == 'zone') %>%
  .$trait_value %>% paste0(collapse = '|')

spp_data_zones <- raw_data_df %>%
  filter(trait == 'zone') %>%
  ### fix misspelling:
  mutate(tmp = str_extract_all(tolower(trait_value), zone_vals)) %>%
  unnest(tmp) %>%
  mutate(trait_val_clean = clean_trait(tmp)) %>%
  clean_up_mess()
```

``` {r clean up mobility traits}
mob_vals <- traitvals_df_valid %>%
  filter(trait == 'adult mobility') %>%
  .$trait_value %>% paste0(collapse = '|')
# "sessile|nearly sessile/sedentary|passive|vertical migrator|mobile resident|horizontal migrator|nomadic"
  
spp_data_mobility <- raw_data_df %>%
  filter(trait == 'adult mobility') %>%
  mutate(tmp = str_replace_all(tolower(trait_value), '[^a-z ]+', ';')) %>%
  ### split and unnest, trim and clean:
  mutate(tmp = str_split(tmp, ';')) %>%
  unnest(tmp) %>%
  ### clean up some inconsistencies
  mutate(tmp = str_replace_all(tmp, 'horiz[a-z]+', 'horizontal'),
         tmp = str_replace_all(tmp, 'vertic[a-z]+', 'vertical'),
         tmp = str_replace_all(tmp, 'migrat[a-z]+', 'migrator'),
         tmp = str_replace_all(tmp, 'residen[a-z]+', 'resident'),
         tmp = str_replace_all(tmp, 'sedentary', 'nearly sessile/sedentary')) %>%
  # mutate(tmp = ifelse(str_detect(tmp, mob_vals),
  #                                 str_extract_all(tmp, mob_vals),
  #                                 tmp)) %>%
  mutate(tmp = str_extract_all(tmp, mob_vals)) %>%
  unnest(tmp) %>%
  mutate(trait_val_clean = clean_trait(tmp)) %>%
  clean_up_mess()

```

``` {r clean up depth traits}
depth_vals <- traitvals_df_valid %>%
  filter(trait == 'depth (min/max)') %>%
  .$trait_value %>% paste0(collapse = '|')

spp_data_depth <- raw_data_df %>%
  filter(trait == 'depth (min/max)') %>%
  mutate(tmp = str_replace_all(tolower(trait_value), '[^a-z0-9 ]+', ';')) %>%
  mutate(tmp = str_extract_all(tmp, depth_vals)) %>%
  unnest(tmp) %>%
  mutate(trait_val_clean = clean_trait(tmp)) %>%
  clean_up_mess()

```

``` {r clean up thermal sensitivity traits}
### ocean warming values are 5°C-10-15-20-25-30°C
spp_data_thermal1 <- raw_data_df %>%
  filter(str_detect(trait, 'thermal - sensitivity to ocean warming')) %>%
  rowwise() %>%
  mutate(trait_num = str_extract_all(trait_value, '[0-9]+') %>% unlist() %>% as.integer() %>% max(),
         trait_num = min(floor(trait_num / 5) * 5, 30),
         trait_num = ifelse(is.infinite(trait_num), NA, trait_num)) %>%
  ungroup() %>%
  mutate(tmp = ifelse(!is.na(trait_num), paste0(trait_num, 'c'),
                                tolower(trait_value))) %>%
  mutate(trait_val_clean = ifelse(str_detect(tmp, 'broad|low sensitivity'), 
                                  '30c', tmp)) %>%
  clean_up_mess()

# spp_data_thermal1$trait_val_clean %>% unique()

### heat spike values are yes/no
spp_data_thermal2 <- raw_data_df %>%
  filter(str_detect(trait, 'thermal - sensitivity to heat spikes')) %>%
  mutate(tmp = tolower(trait_value),
         tmp = case_when(str_detect(tmp, 'broad') ~ 'no',
                         str_detect(tmp, 'narrow|sensitive') ~ 'yes',
                         str_detect(tmp, 'can recover') ~ 'no',
                         str_detect(tmp, 'not likely') ~ 'no',
                         TRUE ~ tmp)) %>%
  mutate(trait_val_clean = str_replace_all(tmp, '[^a-z0-9]+', '_')) %>%
  clean_up_mess()

# spp_data_thermal2$trait_val_clean %>% table()

```

``` {r clean up pH traits}
ph_vals <- traitvals_df_valid %>%
  filter(trait == 'ph') %>%
  .$trait_value %>% paste0(collapse = '|')

### ph values are <7.4|7.5-7.7|7.8-8.2
spp_data_ph <- raw_data_df %>%
  filter(trait == 'ph') %>%
  ### fix a typo:
  mutate(trait_value = str_replace(trait_value, '(?<=\\d),(?=\\d)', '.')) %>%
  ### get mean - find into which category the mean falls
  rowwise() %>%
  mutate(trait_mean = str_extract_all(trait_value, '[0-9.]+') %>% unlist() %>% as.numeric() %>% mean(),
         trait_mean = ifelse(is.infinite(trait_mean), NA, trait_mean)) %>%
  ungroup() %>%
  mutate(tmp = case_when(is.na(trait_mean) ~ tolower(trait_value),
                         trait_mean < 7.5 ~ '<7.4',
                         trait_mean < 7.8 ~ '7.5-7.7',
                         TRUE ~ '7.8-8.2')) %>%
  mutate(tmp = case_when(str_detect(tmp, 'broad|not sensitive') ~ '<7.4', 
                         str_detect(tmp, 'narrow')              ~ '7.8-8.2',
                                    TRUE                        ~ tmp)) %>%
  mutate(trait_val_clean = clean_trait(tmp)) %>%
  clean_up_mess()

# spp_data_ph$trait_val_clean %>% table()
```

``` {r clean up biomineral traits}
biomin1_vals <- traitvals_df_valid %>%
  filter(trait == 'calcium carbonate structure location') %>%
  .$trait_value %>% paste0(collapse = '|')

spp_data_biomin1 <- raw_data_df %>%
  filter(trait == 'calcium carbonate structure location') %>%
  rowwise() %>%
  mutate(tmp = tolower(trait_value),
         tmp = case_when(str_detect(tmp, 'ext.+cover') ~ 'external with a cover',
                         str_detect(tmp, 'calcium carbonate') ~ 'external',
                         str_detect(tmp, biomin1_vals) ~ str_extract_all(tmp, biomin1_vals) %>% 
                                  unlist() %>% paste0(collapse = ';'),
                         TRUE ~ NA_character_)) %>%
  mutate(trait_val_clean = clean_trait(tmp)) %>%
  clean_up_mess()

biomin2_vals <- traitvals_df_valid %>%
  filter(trait == 'biomineral') %>%
  .$trait_value %>% paste0(collapse = '|')

spp_data_biomin2 <- raw_data_df %>%
  filter(trait == 'biomineral') %>%
  rowwise() %>%
  mutate(tmp = tolower(trait_value),
         tmp = str_replace(tmp, 'hi mg', 'high mg'),
         tmp = str_replace(tmp, 'chitin(/caco3)?', 'chitin/caco3 mix'),
         tmp = case_when(str_detect(tmp, biomin2_vals) ~ str_extract_all(tmp, biomin2_vals) %>% 
                                  unlist() %>% paste0(collapse = ';'),
                         TRUE ~ NA_character_)) %>%
  mutate(trait_val_clean = clean_trait(tmp)) %>%
  clean_up_mess()

spp_data_biomin <- bind_rows(spp_data_biomin1, spp_data_biomin2)
```

``` {r clean up body size}
bodysize_vals <- traitvals_df_valid %>%
  filter(trait == 'adult body mass/body size') %>%
  .$trait_value %>% paste0(collapse = '|')

spp_data_bodysize <- raw_data_df %>%
  filter(trait == 'adult body mass/body size') %>%
  mutate(tmp = str_replace_all(trait_value, '.+:', ''),
         tmp = clean_trait(tmp),
         tmp = str_replace(tmp, ' +\\(.+\\)', ''),
         tmp = ifelse(str_detect(tmp, 'not large'), '0.5-49mm;50mm-999mm', tmp), ### demospongiae
         tmp = ifelse(str_detect(tmp, 'large'), '>1000mm', tmp),
         tmp = str_replace(tmp, '>?1000[^a-z]|>?1000$', '>1000mm'),
         tmp = str_replace_all(tmp, '(?<=[0-9])$', 'mm'),
         tmp = str_replace_all(tmp, '(?<=[0-9])(?=[^a-z0-9\\.])', 'mm'),
         tmp = str_replace_all(tmp, '5.+->', '50mm-999mm;>')) %>%
  rowwise() %>%
  mutate(tmp = ifelse(str_detect(tmp, bodysize_vals), 
                      str_extract_all(tmp, bodysize_vals) %>% unlist() %>% paste(collapse = ';'),
                      NA)) %>%
  mutate(trait_val_clean = clean_trait(tmp)) %>%
  clean_up_mess()

```

``` {r clean up fecundity}
### Here, extract numerics from the string, use the min and max values to
### identify the span, then assign categories within that span. UGH

fecund_lims <- traitvals_df_valid %>%
  filter(trait == 'fecundity') %>%
  rowwise() %>%
  mutate(vals = str_extract_all(trait_value, '[0-9]+'),
         fmin = as.integer(vals[1]), 
         fmax = as.integer(vals[2])) %>%
  ungroup() %>%
  mutate(fmin = ifelse(trait_value == '<1', 0, fmin),
         fmax = ifelse(trait_value == '<1', 1, fmax),
         fmax = ifelse(trait_value == '>10000', 10001, fmax)) %>%
  select(trait_value, fmin, fmax) %>%
  arrange(fmin) %>%
  mutate(gp = 1:n(),
         ftmp = NA) %>% ### tmp
  group_by(gp) %>%
  complete(ftmp = fmin:(fmax-1), nesting(trait_value, fmin, fmax)) %>%
  filter(!is.na(ftmp)) %>%
  ungroup() %>%
  mutate(fmin = ftmp,
         fmax = ftmp+1,
         fmax = ifelse(fmax > 10000, Inf, fmax)) %>%
  distinct()
  

spp_data_fecund <- raw_data_df %>%
  filter(trait == 'fecundity') %>%
  filter(!is.na(trait_value)) %>%
  rowwise() %>%
  mutate(tmp = clean_trait(trait_value),
         tmp = str_replace_all(tmp, 'to ', '-'),
         tmp = str_split(tmp, ';')) %>%
  unnest(tmp) %>%
  group_by(spp_gp, sheet) %>%
  mutate(tmp_sep = 1:n()) %>%
  rowwise() %>%
  mutate(vals = str_extract_all(tmp, '[0-9]+')) %>%
  ungroup() %>%
  unnest(vals) %>%
  group_by(spp_gp, sheet, tmp_sep) %>%
  mutate(vals = as.integer(vals),
         fmin = min(vals),
         fmin = ifelse(str_detect(tmp, '<1[^0-9]|<1$'), 0, fmin),
         fmax = max(vals),
         fmax = ifelse(str_detect(tmp, '>10000'), Inf, fmax)) %>%
  left_join(fecund_lims %>% select(fmin, gp_min = gp), by = 'fmin') %>%
  left_join(fecund_lims %>% select(fmax, gp_max = gp), by = 'fmax') %>%
  mutate(gp_max = ifelse(gp_min > gp_max, gp_min, gp_max),
         gp = NA) %>% ### tmp
  distinct() %>%
  group_by(spp_gp, sheet, tmp_sep) %>%
  complete(gp = gp_min:gp_max, nesting(category, trait, trait_value, spp_gp, sheet)) %>%
  ungroup() %>%
  filter(!is.na(gp)) %>%
  left_join(fecund_lims %>% select(gp, trait_val_clean = trait_value), by = 'gp') %>%
  select(category, trait, trait_value, spp_gp, sheet, trait_val_clean) %>%
  distinct()

```

``` {r clean up global pop size}
### Here, extract numerics from the string, use the min and max values to
### identify the span, then assign categories within that span. UGH

pop_lims <- traitvals_df_valid %>%
  filter(trait == 'global population size') %>%
  mutate(trait_value = str_replace_all(trait_value, 'k', '000'),
         trait_value = str_replace_all(trait_value, 'm', '000000')) %>%
  rowwise() %>%
  mutate(vals = str_extract_all(trait_value, '[0-9]+'),
         fmin = as.integer(vals[1]), 
         fmax = as.integer(vals[2])) %>%
  ungroup() %>%
  mutate(fmin = ifelse(trait_value == '<1000', 0, fmin),
         fmax = ifelse(trait_value == '<1000', 1000, fmax),
         fmax = ifelse(trait_value == '>1000000', 1000001, fmax)) %>%
  select(trait_value, fmin, fmax) %>%
  arrange(fmin) %>%
  mutate(gp = 1:n(),
         ftmp = NA) %>% ### tmp
  group_by(gp) %>%
  complete(ftmp = fmin:(fmax-1), nesting(trait_value, fmin, fmax)) %>%
  filter(!is.na(ftmp)) %>%
  ungroup() %>%
  mutate(fmin = ftmp,
         fmax = ftmp+1,
         fmax = ifelse(fmax > 1000000, Inf, fmax)) %>%
  distinct()
  

spp_data_pop <- raw_data_df %>%
  filter(trait == 'global population size') %>%
  filter(!is.na(trait_value)) %>%
  rowwise() %>%
  mutate(tmp = clean_trait(trait_value),
         tmp = str_replace_all(tmp, '(?<=[0-9])k', '000'),
         tmp = str_replace_all(tmp, '(?<=[0-9])m', '000000'),
         tmp = str_split(tmp, ';')) %>%
  unnest(tmp) %>%
  group_by(spp_gp, sheet) %>%
  mutate(tmp_sep = 1:n()) %>%
  rowwise() %>%
  mutate(vals = str_extract_all(tmp, '[0-9]+')) %>%
  ungroup() %>%
  unnest(vals) %>%
  group_by(spp_gp, sheet, tmp_sep) %>%
  mutate(vals = as.integer(vals),
         fmin = min(vals),
         fmin = ifelse(str_detect(tmp, '<1[^0-9]|<1$'), 0, fmin),
         fmax = max(vals),
         fmax = ifelse(str_detect(tmp, '>10000'), Inf, fmax)) %>%
  left_join(pop_lims %>% select(fmin, gp_min = gp), by = 'fmin') %>%
  left_join(pop_lims %>% select(fmax, gp_max = gp), by = 'fmax') %>%
  mutate(gp_max = ifelse(gp_min > gp_max, gp_min, gp_max),
         gp = NA) %>% ### tmp
  distinct() %>%
  group_by(spp_gp, sheet, tmp_sep) %>%
  complete(gp = gp_min:gp_max, nesting(category, trait, trait_value, spp_gp, sheet)) %>%
  ungroup() %>%
  filter(!is.na(gp)) %>%
  left_join(pop_lims %>% select(gp, trait_val_clean = trait_value) %>% distinct(), by = 'gp') %>%
  select(category, trait, trait_value, spp_gp, sheet, trait_val_clean) %>%
  distinct() %>%
  ### convert back to m and k versions... UGH
  mutate(trait_val_clean = str_replace_all(trait_val_clean, '000000', 'm'),
         trait_val_clean = str_replace_all(trait_val_clean, '000(?=[^0-9])|000$', 'k'),
         trait_val_clean = str_replace_all(trait_val_clean, '<1k', '<1000'))

x <- spp_data_pop %>% select(trait_value, trait_val_clean) %>% distinct()

```

``` {r clean up max age}
### Here, extract numerics from the string, use the min and max values to
### identify the span, then assign categories within that span. UGH

age_lims <- traitvals_df_valid %>%
  filter(trait == 'max age') %>%
  rowwise() %>%
  mutate(vals = str_extract_all(trait_value, '[0-9]+'),
         fmin = as.integer(vals[1]), 
         fmax = as.integer(vals[2])) %>%
  ungroup() %>%
  mutate(fmin = ifelse(str_detect(trait_value, '3month'), 0, fmin),
         fmax = ifelse(str_detect(trait_value, '3month'), 1, fmax),
         fmax = ifelse(trait_value == '>100yrs', 101, fmax)) %>%
  select(trait_value, fmin, fmax) %>%
  arrange(fmin, trait_value) %>%
  mutate(gp = 1:n(),
         ftmp = NA) %>% ### tmp
  group_by(gp) %>%
  complete(ftmp = fmin:(fmax-1), nesting(trait_value, fmin, fmax)) %>%
  filter(!is.na(ftmp)) %>%
  ungroup() %>%
  mutate(fmin = ftmp,   fmin = ifelse(trait_value == '3months-1yr', .25, fmin),
         fmax = ftmp+1, fmax = ifelse(trait_value == '<3months', .25, fmax),
         fmax = ifelse(fmax > 100, Inf, fmax)) %>%
  distinct()
  

spp_data_age <- raw_data_df %>%
  filter(trait == 'max age') %>%
  filter(!is.na(trait_value)) %>%
  rowwise() %>%
  mutate(tmp = str_replace_all(trait_value, '.+:|\\(.+\\)', ''),
         tmp = clean_trait(tmp),
         tmp = str_replace_all(tmp, '3month', '0.25'),
         tmp = str_split(tmp, ';')) %>%
  unnest(tmp) %>%
  group_by(spp_gp, sheet) %>%
  mutate(tmp_sep = 1:n()) %>%
  rowwise() %>%
  mutate(vals = str_extract_all(tmp, '[0-9\\.]+')) %>%
  ungroup() %>%
  unnest(vals) %>%
  group_by(spp_gp, sheet, tmp_sep) %>%
  mutate(vals = as.numeric(vals),
         fmin = min(vals),
         fmax = max(vals),
         fmin = ifelse(str_detect(tmp, '<0.25'), 0, fmin),
         fmax = ifelse(fmax > 100, Inf, fmax)) %>%
  left_join(age_lims %>% select(fmin, gp_min = gp), by = 'fmin') %>%
  left_join(age_lims %>% select(fmax, gp_max = gp), by = 'fmax') %>%
  mutate(gp_max = ifelse(gp_min > gp_max, gp_min, gp_max),
         gp = NA) %>% ### tmp
  distinct() %>%
  group_by(spp_gp, sheet, tmp_sep) %>%
  complete(gp = gp_min:gp_max, nesting(category, trait, trait_value, spp_gp, sheet)) %>%
  ungroup() %>%
  filter(!is.na(gp)) %>%
  left_join(age_lims %>% select(gp, trait_val_clean = trait_value) %>% distinct(), by = 'gp') %>%
  select(category, trait, trait_value, spp_gp, sheet, trait_val_clean) %>%
  distinct()

x <- spp_data_age %>% select(trait_value, trait_val_clean) %>% distinct()

```

``` {r clean up gen time}
### Here, extract numerics from the string, use the min and max values to
### identify the span, then assign categories within that span. UGH

gen_time_lims <- traitvals_df_valid %>%
  filter(trait == 'age to 1st reproduction/generation time') %>%
  rowwise() %>%
  mutate(vals = str_extract_all(trait_value, '[0-9]+'),
         fmin = as.integer(vals[1]), 
         fmax = as.integer(vals[2])) %>%
  ungroup() %>%
  mutate(fmin = ifelse(trait_value == '<1yr', 0, fmin),
         fmax = ifelse(trait_value == '<1yr', 1, fmax),
         fmax = ifelse(trait_value == '>20yrs', 21, fmax)) %>%
  select(trait_value, fmin, fmax) %>%
  arrange(fmin) %>%
  mutate(gp = 1:n(),
         ftmp = NA) %>% ### tmp
  group_by(gp) %>%
  complete(ftmp = fmin:(fmax-1), nesting(trait_value, fmin, fmax)) %>%
  filter(!is.na(ftmp)) %>%
  ungroup() %>%
  mutate(fmin = ftmp,
         fmax = ftmp+1,
         fmax = ifelse(fmax > 20, Inf, fmax)) %>%
  distinct()
  

spp_data_gen_time <- raw_data_df %>%
  filter(trait == 'age to 1st reproduction/generation time') %>%
  filter(!is.na(trait_value)) %>%
  rowwise() %>%
  mutate(tmp = str_replace_all(trait_value, '\\(.*\\)', ''),
         tmp = str_replace_all(tmp, '.+:', ''),
         tmp = clean_trait(tmp),
         tmp = str_split(tmp, ';')) %>%
  unnest(tmp) %>%
  group_by(spp_gp, sheet) %>%
  mutate(tmp_sep = 1:n()) %>%
  rowwise() %>%
  mutate(vals = str_extract_all(tmp, '[0-9]+')) %>%
  ungroup() %>%
  unnest(vals) %>%
  group_by(spp_gp, sheet, tmp_sep) %>%
  mutate(vals = as.integer(vals),
         fmin = min(vals),
         fmin = ifelse(str_detect(tmp, '<1[^0-9]|<1$'), 0, fmin),
         fmax = max(vals),
         fmax = ifelse(fmax > 20, Inf, fmax)) %>%
  left_join(gen_time_lims %>% select(fmin, gp_min = gp), by = 'fmin') %>%
  left_join(gen_time_lims %>% select(fmax, gp_max = gp), by = 'fmax') %>%
  mutate(gp_max = ifelse(gp_min > gp_max, gp_min, gp_max),
         gp = NA) %>% ### tmp
  distinct() %>%
  group_by(spp_gp, sheet, tmp_sep) %>%
  complete(gp = gp_min:gp_max, nesting(category, trait, trait_value, spp_gp, sheet)) %>%
  ungroup() %>%
  filter(!is.na(gp)) %>%
  left_join(gen_time_lims %>% select(gp, trait_val_clean = trait_value) %>% distinct(), by = 'gp') %>%
  select(category, trait, trait_value, spp_gp, sheet, trait_val_clean) %>%
  distinct()

x <- spp_data_gen_time %>% select(trait_value, trait_val_clean) %>% distinct()

y <- spp_data_gen_time %>%
  filter(str_detect(trait_value, 'meter|feet|foot'))
```

``` {r clean up lifetime reprod opps}
### Here, extract numerics from the string, use the min and max values to
### identify the span, then assign categories within that span. UGH

reprod_lims <- traitvals_df_valid %>%
  filter(trait == 'lifetime # reproductive opportunities') %>%
  rowwise() %>%
  mutate(vals = str_extract_all(trait_value, '[0-9]+'),
         fmin = as.integer(vals[1]), 
         fmax = as.integer(vals[2])) %>%
  ungroup() %>%
  mutate(fmin = ifelse(trait_value == '1', 0, fmin),
         fmax = ifelse(trait_value == '1', 1, fmax),
         fmax = ifelse(trait_value == '>100', 100, fmax)) %>%
  select(trait_value, fmin, fmax) %>%
  arrange(fmin) %>%
  mutate(gp = 1:n(),
         ftmp = NA) %>% ### tmp
  group_by(gp) %>%
  complete(ftmp = fmin:fmax, nesting(trait_value, fmin, fmax)) %>%
  filter(!is.na(ftmp)) %>%
  ungroup() %>%
  mutate(fmin = ftmp,
         fmax = ftmp+1,
         fmax = ifelse(fmax > 100, Inf, fmax)) %>%
  distinct() %>%
  filter(!(trait_value == '51-100' & fmin == 100))
  

spp_data_reprod <- raw_data_df %>%
  filter(trait == 'lifetime # reproductive opportunities') %>%
  filter(!is.na(trait_value)) %>%
  rowwise() %>%
  mutate(tmp = clean_trait(trait_value),
         tmp = str_replace_all(tmp, '\\(.+\\)', ''),
         tmp = str_split(tmp, ';')) %>%
  unnest(tmp) %>%
  group_by(spp_gp, sheet) %>%
  mutate(tmp_sep = 1:n()) %>%
  rowwise() %>%
  mutate(vals = str_extract_all(tmp, '[0-9]+')) %>%
  ungroup() %>%
  unnest(vals) %>%
  group_by(spp_gp, sheet, tmp_sep) %>%
  mutate(vals = as.integer(vals),
         fmin = min(vals),
         fmax = max(vals),
         fmin = ifelse(tmp == '1', 0, fmin),
         fmax = ifelse(str_detect(tmp, '>100'), Inf, fmax)) %>%
  left_join(reprod_lims %>% select(fmin, gp_min = gp), by = 'fmin') %>%
  left_join(reprod_lims %>% select(fmax, gp_max = gp), by = 'fmax') %>%
  mutate(gp_max = ifelse(gp_min > gp_max, gp_min, gp_max),
         gp = NA) %>% ### tmp
  distinct() %>%
  group_by(spp_gp, sheet, tmp_sep) %>%
  complete(gp = gp_min:gp_max, nesting(category, trait, trait_value, spp_gp, sheet)) %>%
  ungroup() %>%
  filter(!is.na(gp)) %>%
  left_join(reprod_lims %>% select(gp, trait_val_clean = trait_value) %>% distinct(), by = 'gp') %>%
  select(category, trait, trait_value, spp_gp, sheet, trait_val_clean) %>%
  distinct()

x <- spp_data_reprod %>% select(trait_value, trait_val_clean) %>% distinct()

```

``` {r clean up number of sites}
### Here, sub in reasonable values.  If aggregates but uncertain, assign
### all aggregation values and let the code find the mean value. UGH

nsite_vals <- 'one|few|many|does not aggregate'
### one, few, many, does not aggregate

spp_data_nsite <- raw_data_df %>%
  filter(str_detect(trait, 'number of sites')) %>%
  mutate(tmp = str_replace_all(trait_value, '\\(.+\\)', ''),
         tmp = clean_trait(tmp)) %>%
  rowwise() %>%
  mutate(tmp1 = case_when(str_detect(tmp, 'entire distribution|small') ~ 'one',
                          str_detect(tmp, '^n') ~ 'does not aggregate',
                          str_detect(tmp, nsite_vals) ~ str_extract_all(tmp, nsite_vals) %>% 
                            unlist() %>% paste0(collapse = ';'), ### extract vals in a sec
                          str_detect(tmp, '(?<!not )aggreg|yes') ~ 'one;few;many',
                          TRUE ~ NA_character_),
         tmp1 = str_split(tmp1, ';')) %>%
  ungroup() %>%
  unnest(tmp1) %>%
  mutate(trait_val_clean = clean_trait(tmp1)) %>%
  clean_up_mess()

x <- spp_data_nsite$trait_val_clean %>% unique()

```

``` {r clean up pressure sensitive structures}
### Lungs don't seem to be particularly sensitive to high power sonar;
### guessing gas bladders as well.  Assign low sensitivity.

pressure_vals <- traitvals_df_valid %>%
  filter(trait == 'extreme pressure wave sensitive structures') %>%
  .$trait_value
  
spp_data_prs <- raw_data_df %>%
  filter(trait == 'extreme pressure wave sensitive structures') %>%
  filter(!is.na(trait_value)) %>%
  mutate(tmp = str_replace_all(trait_value, 'sensitivity', ''),
         tmp = clean_trait(tmp),
         tmp = case_when(tmp == 'probably'      ~ 'medium',
                         tmp == 'probably not'  ~ 'low',
                         str_detect(tmp, 'yes') ~ 'high',
                         str_detect(tmp, 'no')  ~ 'none',
                         str_detect(tmp, 'lung|gas bladder') ~ 'low',
                         TRUE ~ NA_character_)) %>%
  mutate(trait_val_clean = clean_trait(tmp)) %>%
  clean_up_mess()
  
```

``` {r clean up parental investment}
### create a super clean version to match str_extracted values
parent_vals <- traitvals_df_valid %>%
  filter(trait == 'parental investment') %>%
  select(trait_val_clean = trait_value) %>%
  mutate(tmp = str_split(trait_val_clean, ';|/')) %>%
  unnest(tmp) %>%
  mutate(tmp = str_replace_all(tmp, '[^a-z]', '')) %>%
  arrange(desc(tmp)) ### to get unattended to match first!
# "live birth/egg care" "spawner" "egg-layer" "egg-layer (unattended)"
parent_match <- parent_vals$tmp %>% paste0(collapse = '|')

spp_data_parent <- raw_data_df %>%
  filter(trait == 'parental investment') %>%
  filter(!is.na(trait_value)) %>%
  mutate(tmp = clean_trait(trait_value),
         tmp = str_split(tmp, ';|/|and')) %>%
  unnest(tmp) %>%
  mutate(tmp = str_replace_all(tmp, '[^a-z]', ''),
         tmp = str_extract(tmp, parent_match)) %>%
  left_join(parent_vals, by = 'tmp') %>%
  clean_up_mess()
  
x <- spp_data_parent %>% select(trait_value, trait_val_clean) %>% distinct()
```

### combine into a relatively clean df

``` {r}

cleaned_traits <- c('zone', 'adult mobility', 
                    'fecundity',
                    'parental investment',
                    'global population size',
                    'max age',
                    'depth (min/max)', 'ph',
                    'number of sites',
                    'number of sites, incl. terrestrial wetlands',
                    'age to 1st reproduction/generation time',
                    'lifetime # reproductive opportunities',
                    'thermal - sensitivity to ocean warming - max temps tolerated',
                    'thermal - sensitivity to heat spikes/heat waves',
                    'extreme pressure wave sensitive structures',
                    'adult body mass/body size',
                    'biomineral',
                    'calcium carbonate structure location')

spp_data_clean <- raw_data_df %>%
  filter(!trait %in% cleaned_traits) %>%
  mutate(trait_val_clean = clean_trait(trait_value)) %>%
  clean_up_mess() %>%
  bind_rows(spp_data_zones) %>%
  bind_rows(spp_data_mobility) %>%
  bind_rows(spp_data_depth) %>%
  bind_rows(spp_data_thermal1) %>%
  bind_rows(spp_data_thermal2) %>%
  bind_rows(spp_data_ph) %>%
  bind_rows(spp_data_biomin) %>%
  bind_rows(spp_data_bodysize) %>%
  bind_rows(spp_data_fecund) %>%
  bind_rows(spp_data_pop) %>%
  bind_rows(spp_data_prs) %>%
  bind_rows(spp_data_gen_time) %>%
  bind_rows(spp_data_reprod) %>%
  bind_rows(spp_data_nsite) %>%
  bind_rows(spp_data_parent) %>%
  bind_rows(spp_data_age) %>%
  ### split and unnest, trim and clean:
  mutate(trait_val_clean = str_split(trait_val_clean, ';')) %>%
  unnest(trait_val_clean)

x <- spp_data_clean %>% select(trait, trait_value, trait_val_clean) %>% distinct()

```

### write out clean species group sheets.  NOTE: After running, set this to eval = FALSE to avoid overwriting later manual edits 


Here we need to recombine multiple trait vals into one line, separate using a semicolon for easy splitting later.

```{r, eval = TRUE}
spp_data_out <- spp_data_clean %>%
  mutate(spp_gp = tolower(spp_gp)) %>%
  rename(trait_val_orig = trait_value) %>%
  group_by(category, trait, sheet, spp_gp, trait_val_orig) %>%
  summarize(trait_val_clean = paste0(trait_val_clean, collapse = ';')) %>%
  ungroup()

sheets <- spp_data_out$sheet %>% unique()

for(s in sheets) { ### s <- sheets[1]
  spp_gp_data <- spp_data_out %>%
    filter(sheet == s) %>%
    select(-trait_val_orig, -sheet) %>%
    spread(spp_gp, trait_val_clean)
  
  fstem <- here('_raw_data/spp_trait_csvs/spp_traits_%s.csv')
  write_csv(spp_gp_data, sprintf(fstem, s))
}
```


