---
title: "Downstream taxa vulnerability"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

source('https://raw.githubusercontent.com/oharac/src/master/R/common.R')
library(taxize)

```

# Summary

Using taxonomic trees from WoRMS and the `taxize` package, we will try filling vulnerabilities for downstream non-scored species.

# Methods

* Load species vulnerabilities for known species.  
* Join the known species vulnerabilities to the expanded taxonomic list to get the full classification.
* For vulnerabilities calculated at a non-species level, we will downfill those to the species level (e.g., we know family level traits therefore calculate vulnerability - assign to all non-specified species in that family).

## Assemble the taxonomic dataframe

Grab data from each rank (kingdom --> phylum, phylum --> class, class --> order, etc.) and assemble into a long dataframe.  Long format will be easier to match trait-scored species to, since all ranks will be in the "name" column.  But wide format will be easier for keeping track of the structure of each species' classification.

``` {r}
p_from_k <- read_csv(here('int/phylum_from_kingdom_worms.csv')) %>%
  filter(!is.na(id))
c_from_p <- read_csv(here('int/class_from_phylum_worms.csv')) %>%
  filter(!is.na(id))
o_from_c <- read_csv(here('int/order_from_class_worms.csv')) %>%
  filter(!is.na(id))
f_from_o <- read_csv(here('int/family_from_order_worms.csv')) %>%
  filter(!is.na(id))
g_from_f <- read_csv(here('int/genus_from_family_worms.csv')) %>%
  filter(!is.na(id))
s_from_g <- read_csv(here('int/species_from_genus_worms.csv')) %>%
  filter(!is.na(id))

rank_lvls <- c('kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species')

### create long df to match at any level
spp_df_long <- bind_rows(s_from_g, g_from_f, f_from_o, o_from_c, c_from_p, p_from_k) %>%
  mutate(rank = factor(rank, levels = rank_lvls)) %>%
  filter(!is.na(name))

full_class_file <- here('_data/spp_complete_classifications_worms.csv')
if(!file.exists(full_class_file)) {
  ### write this out; this can be used to recreate full classifications later
  write_csv(spp_df_long, full_class_file)
}

### create wide for complete classification for each species
spp_df_wide <- s_from_g %>%
  select(genus = parent, species = name) %>%
  left_join(g_from_f %>% select(family = parent, genus = name), 
            by = c('genus')) %>%
  left_join(f_from_o %>% select(order = parent, family = name), 
            by = c('family')) %>%
  left_join(o_from_c %>% select(class = parent, order = name), 
            by = c('order')) %>%
  left_join(c_from_p %>% select(phylum = parent, class = name), 
            by = c('class')) %>%
  left_join(p_from_k %>% select(kingdom = parent, phylum = name),
            by = c('phylum')) %>%
  select(kingdom, phylum, class, order, family, genus, species) %>%
  distinct()

### then make that long, but keeping structure for each species - maybe?
# spp_all_long <- spp_df_wide %>%
#   mutate(spp = species) %>%
#   gather(rank, name, kingdom:species) %>%
#   mutate(rank = factor(rank, levels = rank_lvls))
```

## Match species with known vulnerability to most specific rank

Loading the vulnerability data, and match to the long-format species classifications.  Then join these together sequentially by each level.

``` {r match up}
spp_gp_vuln <- read_csv(here('_output/spp_gp_vuln_w_distribution.csv')) %>%
  select(taxon, spp_gp, stressor, vuln, sd_vuln)

matched_df <- spp_df_long %>%
  inner_join(spp_gp_vuln, by = c('name' = 'spp_gp')) %>%
  mutate(match = rank)
# matched_df$rank %>% unique() # species genus   family  class
```

``` {r identify unmatched species problems}
check_status <- function(check_ids) {
  check_ids <- check_ids[!is.na(check_ids)]
  n_chunks <- ceiling(length(check_ids) / 50)
  records_list <- vector('list', length = n_chunks)
  for(i in 1:n_chunks) {
    indices <- ((i-1)*50 + 1):min(i*50, length(check_ids))
    ids_chunk <- check_ids[indices]
    ids_param <- paste0('aphiaids[]=', ids_chunk, collapse = '&')
    records_url <- paste0('https://www.marinespecies.org/rest/AphiaRecordsByAphiaIDs?', ids_param)
    records_list[[i]] <- jsonlite::fromJSON(records_url) %>%
      select(id = AphiaID, sciname = scientificname, status) %>%
      distinct()
  }
  records_df <- records_list %>% 
    bind_rows()
  return(records_df)
}

unmatched_df <- spp_gp_vuln %>%
  filter(!spp_gp %in% matched_df$name) %>%
  select(taxon, spp_gp) %>%
  distinct()

check_class_list <- classification(unmatched_df$spp_gp, db = 'worms') %>%
  setNames(unmatched_df$spp_gp)
check_class_df <- check_class_list[!is.na(check_class_list)] %>%
  bind_rows(.id = 'spp_gp_orig') %>%
  mutate_if(is.character, tolower)
check_accepted_df <- check_status(check_class_df$id) %>%
  mutate(sciname = tolower(sciname))

unmatch_check_df <- unmatched_df %>%
  mutate(found = !is.na(check_class_list)) %>%
  left_join(check_class_df, by = c('spp_gp' = 'name')) %>%
  left_join(check_accepted_df, by = c('spp_gp' = 'sciname', 'id'))
```

### Unmatched spp groups with scored traits:

`r DT::datatable(unmatch_check_df)`

* Problems where a taxon is found, and accepted, may mean error in the `downstream` call.  Check the various `X_from_X.csv` dataframes to figure out where this taxon is being dropped.
* problems where a taxon is found, but not accepted (or not a main rank), may indicate species where an alternate name will fix the issue.
    * many of these have been identified and fixed in the original traits xlsx, with notes of expert-provided name
* problems where a taxon is not found may indicate typos, non-standard spellings, or species not yet in WoRMS
    * many of these have been identified and fixed in the original traits xlsx, with notes of expert-provided name

Specific problems:

* _Cellana tramoserica_ upstream has no "order" rank.
* _Ostrea angasi_ seems legit but not recognized in WoRMS.

## Expand classification for matched species

Identify the rank at which each spp group matched, and disambiguate spp gps that match at multiple ranks to identify the most specific rank. 

``` {r}
### Loop over matchable ranks to separate out the matched species by rank of match
match_ranks <- c('phylum', 'class', 'order', 'family', 'genus', 'species')
rank_partitions <- vector('list', length = length(match_ranks)) %>%
  setNames(match_ranks)
for(r in match_ranks) { # r <- match_ranks[1]
  rank_partitions[[r]] <- matched_df %>%
    filter(rank == r) %>%
    select(!!paste0('match_', r) := match, !!r := name, 
           stressor, vuln, sd_vuln, taxon)
}

### Expand matched species to get full classification
match_exp <- spp_df_wide
for(r in match_ranks) {
  ### r <- 'class'
  tmp <- rank_partitions[[r]] %>%
    select(contains('match'), !!r) %>%
    distinct()
  match_exp <- match_exp %>%
    left_join(tmp, by = r)
}

### Disambiguate expanded matches to the most specific rank available
match_exp_dis <- match_exp %>%
  gather(key, match_rank, starts_with('match')) %>%
  ### filter unmatched species
  filter(!is.na(match_rank)) %>%
  ### keep the most specific match level
  mutate(match_rank = factor(match_rank, levels = rank_lvls)) %>%
  group_by(species) %>%
  filter(as.integer(match_rank) == max(as.integer(match_rank))) %>%
  ungroup() %>%
  select(-key) %>%
  distinct()

### Loop over the matchable ranks again, to dice the expanded match and
### join trait values by match rank.
match_vuln_list <- vector('list', length = length(match_ranks)) %>%
  setNames(match_ranks)
for(r in match_ranks) {
  ### r <- 'class'
  tmp_rank_part <- rank_partitions[[r]] %>%
    rename(match_rank := !!paste0('match_', r))
  match_vuln_list[[r]] <- match_exp_dis %>%
    filter(match_rank == r) %>%
    left_join(tmp_rank_part, by = c(r, 'match_rank'))
}

match_vuln_df <- bind_rows(match_vuln_list) %>%
  ### disambiguate rossia (chromista vs cephalopoda)
  filter(!(taxon == 'cephalopods' & kingdom != 'animalia'))

### Split into a species match table and vulnerability table, with an ID number
### to facilitate later matching up
match_spp <- match_vuln_df %>%
  select(kingdom:species, taxon, match_rank) %>%
  distinct() %>%
  arrange(taxon, species) %>%
  mutate(spp_id = 1:n())

spp_vuln <- match_vuln_df %>%
  select(species, taxon, stressor, vuln, sd_vuln) %>%
  distinct() %>%
  left_join(match_spp %>% select(taxon, species, spp_id), by = c('taxon', 'species')) %>%
  mutate(vuln = round(vuln, 5), sd_vuln = round(sd_vuln, 5)) %>%
  select(-taxon, -species) ### get these back by matching with spp_id

write_csv(match_spp, here('int/spp_match_downfill.csv'))
write_csv(spp_vuln,  here('int/vuln_downfill_only.csv'))
```

### How many matched at each level?

There are `r n_distinct(match_vuln_df$species)` (i.e., for taxa scored at the class level, how many species can be included, vs. for taxa at the species level):

``` {r}
knitr::kable(match_vuln_df %>% 
               group_by(match_rank) %>% 
               summarize(n_spp_matched = n_distinct(species)))
```

### Taxonomic breakdown?

```{r}
knitr::kable(match_vuln_df %>%
               group_by(taxon) %>%
               summarize(n_spp_matched = n_distinct(species)))
```

