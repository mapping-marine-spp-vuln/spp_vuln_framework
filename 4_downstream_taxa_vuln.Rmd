---
title: "Downstream taxa vulnerability"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

library(oharac) ### remotes::install_github('oharac/oharac')
oharac::setup()
# source('https://raw.githubusercontent.com/oharac/src/master/R/common.R')
source(here('common_fxns.R'))
library(taxize)

```

# Summary

Using taxonomic trees from WoRMS and the `taxize` package, we will try filling vulnerabilities for downstream non-scored species.

# Methods

* Load species vulnerabilities for known species.  
* Join the known species vulnerabilities to the expanded taxonomic list to get the full classification.
* For vulnerabilities calculated at a non-species level, we will downfill those to the species level (e.g., we know family level traits therefore calculate vulnerability - assign to all non-specified species in that family).

## Assemble the taxonomic dataframe

Grab data from each rank (kingdom --> phylum, phylum --> class, class --> order, etc.) and assemble into a long dataframe.  Long format will be easier to match trait-scored species to, since all ranks will be in the "name" column.  But wide format will be easier for keeping track of the structure of each species' classification.

Because we are dropping plants and algae, filter wide dataframe to just species in kingdom _Animalia_.  This is done in the `assemble_worms()` function from `common_fxns.R`.

``` {r assemble full spp taxonomic table from WoRMS}
spp_all_wide <- assemble_worms('wide')
spp_all_long <- assemble_worms('long')
```

### check birds

```{r}
birds <- spp_all_wide %>% filter(class == 'aves')

bird_fam_sum <- birds %>% group_by(family) %>% summarize(n = n_distinct(species))
DT::datatable(bird_fam_sum)
```

## Match species with known vulnerability to most specific rank

Loading the vulnerability data, and match to the long-format species classifications.  Then join these together sequentially by each level.

``` {r match up}
spp_gp_vuln <- read_csv(here('_output/spp_gp_vuln_w_distribution.csv')) %>%
  select(taxon, spp_gp, stressor, vuln, sd_vuln)

matched_df <- spp_all_long %>%
  inner_join(spp_gp_vuln, by = c('name' = 'spp_gp')) %>%
  mutate(match = rank)
# matched_df$rank %>% unique() # species genus   family  class
```

``` {r identify unmatched species problems}
check_status <- function(check_ids) {
  check_ids <- check_ids[!is.na(check_ids)]
  n_chunks <- ceiling(length(check_ids) / 50)
  records_list <- vector('list', length = n_chunks)
  for(i in 1:n_chunks) {
    indices <- ((i-1)*50 + 1):min(i*50, length(check_ids))
    ids_chunk <- check_ids[indices]
    ids_param <- paste0('aphiaids[]=', ids_chunk, collapse = '&')
    records_url <- paste0('https://www.marinespecies.org/rest/AphiaRecordsByAphiaIDs?', ids_param)
    records_list[[i]] <- jsonlite::fromJSON(records_url) %>%
      select(id = AphiaID, sciname = scientificname, status) %>%
      distinct()
  }
  records_df <- records_list %>% 
    bind_rows()
  return(records_df)
}

unmatched_df <- spp_gp_vuln %>%
  filter(!spp_gp %in% matched_df$name) %>%
  select(taxon, spp_gp) %>%
  distinct()

check_class_list <- classification(unmatched_df$spp_gp, db = 'worms') %>%
  setNames(unmatched_df$spp_gp)
check_class_df <- check_class_list[!is.na(check_class_list)] %>%
  bind_rows(.id = 'spp_gp_orig') %>%
  mutate_if(is.character, tolower)
check_accepted_df <- check_status(check_class_df$id) %>%
  mutate(sciname = tolower(sciname))

unmatch_check_df <- unmatched_df %>%
  mutate(found = !is.na(check_class_list)) %>%
  left_join(check_class_df, by = c('spp_gp' = 'name')) %>%
  left_join(check_accepted_df, by = c('spp_gp' = 'sciname', 'id'))
```

### Unmatched spp groups with scored traits:

`r DT::datatable(unmatch_check_df)`

* Problems where a taxon is found, and accepted, may mean error in the `downstream` call.  Check the various `X_from_X.csv` dataframes to figure out where this taxon is being dropped.
* problems where a taxon is found, but not accepted (or not a main rank), may indicate species where an alternate name will fix the issue.
    * many of these have been identified and fixed in the original traits xlsx, with notes of expert-provided name
* problems where a taxon is not found may indicate typos, non-standard spellings, or species not yet in WoRMS
    * many of these have been identified and fixed in the original traits xlsx, with notes of expert-provided name

Specific problems:

* _Cellana tramoserica_ upstream has no "order" rank.
* _Ostrea angasi_ seems legit but not recognized in WoRMS.

## Expand classification for matched species

Identify the rank at which each spp group matched, and disambiguate spp gps that match at multiple ranks to identify the most specific rank. 

``` {r}
### Loop over matchable ranks to separate out the matched species by rank of match
match_ranks <- c('phylum', 'class', 'order', 'family', 'genus', 'species')

rank_partitions <- vector('list', length = length(match_ranks)) %>%
  setNames(match_ranks)

for(r in match_ranks) { # r <- match_ranks[1]
  rank_partitions[[r]] <- matched_df %>%
    filter(rank == r) %>%
    select(!!paste0('match_', r) := match, !!r := name, 
           stressor, vuln, sd_vuln, taxon) %>%
    distinct()
}

### Expand matched species to get full classification
match_exp <- spp_all_wide

for(r in match_ranks) {
  ### r <- 'class'
  tmp <- rank_partitions[[r]] %>%
    select(contains('match'), !!r) %>%
    distinct()
  match_exp <- match_exp %>%
    left_join(tmp, by = r)
}

### Disambiguate expanded matches to the most specific rank available
match_exp_dis <- match_exp %>%
  gather(key, match_rank, starts_with('match')) %>%
  ### filter unmatched species
  filter(!is.na(match_rank)) %>%
  ### keep the most specific match level
  mutate(match_rank = factor(match_rank, levels = match_ranks)) %>%
  group_by(species) %>%
  filter(as.integer(match_rank) == max(as.integer(match_rank))) %>%
  ungroup() %>%
  select(-key) %>%
  distinct()

### Loop over the matchable ranks again, to dice the expanded match and
### join trait values by match rank.
match_vuln_list <- vector('list', length = length(match_ranks)) %>%
  setNames(match_ranks)

for(r in match_ranks) {
  ### r <- 'class'
  tmp_rank_part <- rank_partitions[[r]] %>%
    rename(match_rank := !!paste0('match_', r))
  match_vuln_list[[r]] <- match_exp_dis %>%
    filter(match_rank == r) %>%
    left_join(tmp_rank_part, by = c(r, 'match_rank'))
}

match_vuln_df <- bind_rows(match_vuln_list) %>%
  ### disambiguate pearl oysters
  filter(genus != 'pinctada' | class == 'bivalvia')

# dupes <- match_vuln_df %>%
#   select(phylum:species, taxon) %>%
#   distinct() %>%
#   show_dupes('species')

### Split into a species match table and vulnerability table, with an ID number
### to facilitate later matching up
match_spp <- match_vuln_df %>%
  select(phylum:species, taxon, match_rank) %>%
  distinct() %>%
  arrange(taxon, species) %>%
  mutate(spp_id = 1:n())

spp_vuln <- match_vuln_df %>%
  select(species, taxon, stressor, vuln, sd_vuln) %>%
  distinct() %>%
  left_join(match_spp %>% select(taxon, species, spp_id), by = c('taxon', 'species')) %>%
  mutate(vuln = round(vuln, 5), sd_vuln = round(sd_vuln, 5)) %>%
  select(-taxon, -species) ### get these back by matching with spp_id

write_csv(match_spp, here('int/spp_match_downfill.csv'))
write_csv(spp_vuln,  here('int/vuln_downfill_only.csv'))
```

### How many matched at each level?

There are `r n_distinct(match_vuln_df$species)` (i.e., for taxa scored at the class level, how many species can be included, vs. for taxa at the species level):

``` {r}
knitr::kable(match_vuln_df %>% 
               group_by(match_rank) %>% 
               summarize(n_spp_matched = n_distinct(species)))
```

### Taxonomic breakdown?

```{r}
knitr::kable(match_vuln_df %>%
               group_by(taxon) %>%
               summarize(n_spp_matched = n_distinct(species)))
```

Total number of species matched with down-fill:

`r n_distinct(match_vuln_df$species)`