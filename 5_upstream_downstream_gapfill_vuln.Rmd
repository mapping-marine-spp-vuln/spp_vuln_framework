---
title: "Upstream-downstream taxa vulnerability gapfill"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

library(oharac) ### remotes::install_github('oharac/oharac')
oharac::setup()
source(here('common_fxns.R'))
options(dplyr.summarise.inform = FALSE) 

### directory on server for large files:
dir_mazu <- '/home/shares/ohi/spp_vuln/spp_vuln_framework'

```

# Summary

Using taxonomic trees from WoRMS and the `taxize` package, we will try filling vulnerabilities for non-scored species using an upstream-downstream method.

# Methods

* For a given rank, calculate distribution parameters based on all known downstream spp (e.g., for genus, calc mean and sd based on all scored spp)
* Then assign those back down to unknown species at the species level.
* For data given at the genus level (or above), this effectively automatically gapfills all species in the genus.
* Repeat for higher levels

## Load expanded vulnerability scores

```{r load expanded vuln scores from script 4}
match_spp <- read_csv(here('int/spp_match_downfill.csv'))
spp_vuln  <- read_csv(here('int/vuln_downfill_only.csv'))

match_vuln_df <- match_spp %>%
  inner_join(spp_vuln, by = 'downfill_spp_id') %>%
  mutate(sd_vuln = ifelse(is.na(sd_vuln), 0, sd_vuln))
```

## Assemble full spp table from WoRMS

Use the `assemble_worms()` function from `common_fxns.R`.

``` {r assemble full spp taxonomic table from WoRMS}
spp_all_wide <- assemble_worms('wide')
spp_all_long <- assemble_worms('long')
```

### Potential for gapfill at each rank

For each rank, identify the taxa included in vulnerability data (e.g. which genera are included in our data, based on any match level).  Count the number of species known (from vulnerability data), unknown but fillable (not specifically in vulnerability data), and unknown and unfillable (no vulnerability for that taxa).

``` {r gapfill potential by rank}

taxa_match_df <- match_vuln_df %>%
  select(phylum:species) %>%
  distinct() %>%
  group_by(species) %>%
  ungroup()

match_ranks <- c('phylum', 'class', 'order', 'family', 'genus', 'species')

rank_gapfill_potential <- vector('list', length = length(match_ranks) - 1) %>%
  setNames(match_ranks[-6])

for(r in match_ranks[-6]) { ### r <- 'phylum'
  rank_spp_known <- taxa_match_df %>%
    rename(tmp := !!r) %>%
    group_by(tmp) %>%
    summarize(n_spp_known = n_distinct(species)) %>%
    ungroup() %>%
    rename(!!r := tmp) 
  rank_spp_all <- spp_all_wide %>%
    rename(tmp := !!r) %>%
    group_by(tmp) %>%
    summarize(n_spp_all = n_distinct(species)) %>%
    ungroup() %>%
    rename(!!r := tmp) %>%
    left_join(rank_spp_known, by = r) %>%
    mutate(n_spp_fill = ifelse(is.na(n_spp_known), 0, n_spp_all - n_spp_known))
  rank_gapfill_potential[[r]] <- rank_spp_all %>% 
    summarize(n_spp_known = sum(n_spp_known, na.rm = TRUE),
              n_spp_fill = sum(n_spp_fill),
              n_spp_unknown = sum(n_spp_all) - n_spp_known - n_spp_fill,
              n_spp_all = sum(n_spp_all),
              rank = r)
}
knitr::kable(bind_rows(rank_gapfill_potential))
  
```

## create gapfill dataframes

Calculate the mean based on all $n$ known species in the rank-level grouping.  This will be broken into taxa with all vulnerability scores deterministic (i.e., no species with a distribution around its vulnerability score) and probabilistic (i.e., one or more species has a distribution around its vulnerability score).

For deterministic taxa, we can calculate a simple mean and standard deviation across vulnerability scores for all species in the taxon.

For probabilistic taxa, we will do a Monte Carlo approach, sampling species from the taxon including variation around the mean for those species with distributions around their vulnerability.

### Deterministic taxa

``` {r identify deterministic taxa-stressor instances}
### Because this seems to keep stalling when crunching genus,
### break into chunks by a higher rank, process separately, then recombine
ords <- match_vuln_df %>%
  group_by(order) %>%
  summarize(n_spp = n_distinct(species)) %>%
  .$order

rank_fill_det <- function(ord, ranks) {
  ### ord <- ords[1]
  rank_lvls <- c('kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species')
  ### find the max rank (max == most specific)
  ranks_fct <- factor(ranks, levels = rank_lvls)
  gp_rank <- ranks_fct[which.max(ranks_fct)] %>% as.character()
  
  message('processing ', paste(ranks, collapse = '/'), ', chunking order ', ord)
  det_tmp <- match_vuln_df %>%
    filter(order == ord) %>%
    group_by(!!!syms(gp_rank), stressor, taxon) %>%
    mutate(tmp = sum(sd_vuln > 0, na.rm = TRUE)) %>%
    filter(tmp == 0) %>%
    group_by(!!!syms(ranks), stressor, taxon) %>%
    summarize(n_spp_known = n_distinct(species),
              mean_vuln = mean(vuln),
              sd_vuln   = sd(vuln), ### this line is causing lags
              # sd_vuln2 = sqrt( sum((vuln - mean_vuln)^2) / (n_spp_known - 1) ),
              .groups = 'drop')
  # message('wrapping up order ', ord)
  return(det_tmp)
}

gen_fill_det <- parallel::mclapply(ords, mc.cores = 20,
                  FUN = rank_fill_det, 
                  ranks = c('class', 'order', 'family', 'genus')) %>%
  bind_rows()
    ### placeholder for additional moments
      # med_vuln  = median(vuln),
      # skew_vuln = psych::skew(vuln, type = 2),
      # kurt_vuln = psych::kurtosi(vuln, type = 2),
      # bimod_coef = mousetrap::bimodality_coefficient(vuln),
      # gapfill = 'genus')
message('...done with genus')
  
fam_fill_det <- parallel::mclapply(ords, mc.cores = 20,
                  FUN = rank_fill_det, 
                  ranks = c('class', 'order', 'family')) %>%
  bind_rows()
message('...done with family')

ord_fill_det <- match_vuln_df %>%
  group_by(class, order, stressor, taxon) %>%
  mutate(tmp = sum(sd_vuln > 0, na.rm = TRUE)) %>%
  filter(tmp == 0) %>%
  summarize(n_spp_known = n_distinct(species),
            mean_vuln = mean(vuln),
            sd_vuln   = sd(vuln), 
            .groups = 'drop')
message('...done with order')

cls_fill_det <- match_vuln_df %>%
  group_by(class, stressor, taxon) %>%
  mutate(tmp = sum(sd_vuln > 0, na.rm = TRUE)) %>%
  filter(tmp == 0) %>%
  summarize(n_spp_known = n_distinct(species),
            mean_vuln = mean(vuln),
            sd_vuln   = sd(vuln), 
            .groups = 'drop')
message('...done with class')

```

### Probabilistic taxa

If any species in the taxon has a distribution around its vulnerability for a stressor (i.e., sd(vulnerability) != 0), check a few things:

* `gen_fill_matchrank`: Are all species in the taxon gapfilled from this rank or a higher rank?  if so, no gapfilling is necessary, as the downstream fill has already necessarily filled all values.
* `gen_fill_nondet_solo`: Are there more than one unique value for vuln and sd_vuln among species within this rank group?  If not, then all spp have identical distributions.  In this case, it is likely that a single probabilistic species represents the entire genus (or whichever level).  Note: ignore ones entirely gapfilled from a higher level.
* `gen_fill_prob`: Leaving out groups matched at higher ranks and species with only one distinct instance of vulnerability values, these remain, with multiple species within the rank group having different vulnerability scores and distributions.

``` {r}

stressors <- match_vuln_df$stressor %>% unique() %>% sort()

```

Let's also tally up the number of species in each rank-level group (e.g., # of species in a given genus or family).

```{r count spp per rank group}
count_ranks <- match_ranks[1:5]
count_list <- vector('list', length = length(count_ranks)) %>%
  setNames(count_ranks)
for(rank in count_ranks) {
  ### rank <- count_ranks[1]
  rank_df <- spp_all_wide %>%
    rename(name := !!rank) %>%
    group_by(name) %>%
    summarize(n_spp_total = n_distinct(species)) %>%
    mutate(rank = rank) %>%
    distinct()
  count_list[[rank]] <- rank_df
}
count_df <- bind_rows(count_list)
```

#### Genus level

``` {r genus prob fill}
gen_fill_nondet <- match_vuln_df %>%
  group_by(class, order, family, genus, stressor, taxon) %>%
  filter(sum(sd_vuln > 0, na.rm = TRUE) > 0) %>%
  ungroup()

gen_fill_matchrank <- gen_fill_nondet %>%
  group_by(class, order, family, genus, stressor, taxon) %>%
  filter(all(match_rank %in% c('class', 'order', 'family', 'genus'))) %>%
  summarize(mean_vuln = first(vuln), 
            sd_vuln = first(sd_vuln), 
            n_spp_known = n_distinct(species)) %>%
  ungroup()

gen_fill_nondet_solo <- gen_fill_nondet %>%
  filter(!genus %in% gen_fill_matchrank$genus) %>%
  group_by(class, order, family, genus, stressor, taxon) %>%
  filter(n_distinct(vuln) == 1 & n_distinct(sd_vuln) == 1) %>%
  summarize(mean_vuln = first(vuln), 
            sd_vuln = first(sd_vuln), 
            n_spp_known = n_distinct(species)) %>%
  ungroup()
  
```

``` {r monte carlo for genus vuln dists}
iters <- 10000
reload <- TRUE
force  <- TRUE
gen_fill_file <- here('int', sprintf('gapfill_gen_prob_results_%s.csv', iters))

if(!file.exists(gen_fill_file) | reload) {
  gen_fill_prob <- gen_fill_nondet %>%
    anti_join(gen_fill_matchrank %>% select(genus, stressor)) %>%
    anti_join(gen_fill_nondet_solo %>% select(genus, stressor)) %>%
    group_by(class, order, family, genus, stressor, taxon)
    
  gen_fill_qty <- gen_fill_prob %>%
    group_by(class, order, family, genus, stressor, taxon) %>%
    summarize(n_spp = n(),
              n_prob = sum(sd_vuln > 0, na.rm = TRUE)) %>%
    filter(n_spp > 1) %>%
    ungroup()
  
  genera <- gen_fill_qty$genus %>% unique() %>% sort()
  
  tmp_fstem <- here('tmp/gen_fill_mc_%s.csv')
  
  trash <- parallel::mclapply(genera, mc.cores = 20,
    FUN = function(g) {### g <- genera[1]
      tmp_file <- sprintf(tmp_fstem, g)
      if(!file.exists(tmp_file) | force) {
        unlink(tmp_file)
        g_df <- gen_fill_prob %>%
          filter(genus == g) %>%
          mutate(sd_vuln = ifelse(is.na(sd_vuln), 0, sd_vuln))
        
        message('Sampling ', iters, ' MC iterations for genus ', g)
    
        mc_results_df <- g_df %>%
          rowwise() %>%
          mutate(v = list(rnorm(iters, mean = vuln, sd = sd_vuln))) %>%
          unnest(v) %>%
          mutate(v = case_when(v < 0 ~ 0, v > 1 ~ 1, TRUE ~ v)) %>%
          group_by(class, order, family, genus, stressor, taxon) %>%
          summarize(mean_vuln = mean(v),
                    sd_vuln = sd(v),
                    # med_vuln = median(v),
                    n_spp_known = n_distinct(species)) %>%
          ungroup()

        write_csv(mc_results_df, tmp_file)
      }
    })
  
  genera_fs <- list.files(here('tmp'), pattern = 'gen_fill_mc.+.csv',
                            full.names = TRUE)
  genera_list <- parallel::mclapply(genera_fs, FUN = read_csv, mc.cores = 20)
  gen_fill_prob_results <- genera_list %>%
    bind_rows() %>%
    left_join(gen_fill_qty)
  
  write_csv(gen_fill_prob_results, gen_fill_file)
}
```

combine all genus-level gapfill values:
```{r}
gen_fill_prob_results <- read_csv(gen_fill_file)


gen_fill_totes <- bind_rows(gen_fill_det,
                            gen_fill_matchrank,
                            gen_fill_nondet_solo,
                            gen_fill_prob_results) %>%
  select(-n_spp) %>%
  mutate(gapfill = 'genus') %>%
  left_join(count_df, by = c('genus' = 'name', 'gapfill' = 'rank'))
```


#### Family level

``` {r family prob fill}
fam_fill_nondet <- match_vuln_df %>%
  group_by(class, order, family, stressor, taxon) %>%
  filter(sum(sd_vuln > 0, na.rm = TRUE) > 0) %>%
  ungroup()

fam_fill_matchrank <- fam_fill_nondet %>%
  group_by(class, order, family, stressor, taxon) %>%
  filter(all(match_rank %in% c('class', 'order', 'family'))) %>%
  summarize(mean_vuln = first(vuln), 
            # med_vuln = first(vuln), 
            sd_vuln = first(sd_vuln), 
            n_spp_known = n_distinct(species)) %>%
  ungroup()

fam_fill_nondet_solo <- fam_fill_nondet %>%
  filter(!family %in% fam_fill_matchrank$family) %>%
  group_by(class, order, family, stressor, taxon) %>%
  filter(n_distinct(vuln) == 1 & n_distinct(sd_vuln) == 1) %>%
  summarize(mean_vuln = first(vuln), 
            # med_vuln = first(vuln), 
            sd_vuln = first(sd_vuln), 
            n_spp_known = n_distinct(species)) %>%
  ungroup()
```

``` {r monte carlo for fam vuln dists}
fam_fill_file <- here('int', sprintf('gapfill_fam_prob_results_%s.csv', iters))

if(!file.exists(fam_fill_file) | reload) {
  fam_fill_prob <- fam_fill_nondet %>%
    anti_join(fam_fill_matchrank %>% select(family, stressor)) %>%
    anti_join(fam_fill_nondet_solo %>% select(family, stressor)) %>%
    group_by(class, order, family, stressor, taxon)
    
  fam_fill_qty <- fam_fill_prob %>%
    group_by(class, order, family, stressor, taxon) %>%
    summarize(n_spp = n(),
              n_prob = sum(sd_vuln > 0, na.rm = TRUE)) %>%
    filter(n_spp > 1) %>%
    ungroup()
  
  fams <- fam_fill_qty$family %>% unique() %>% sort()

  tmp_fstem <- here('tmp/fam_fill_mc_%s.csv')

  trash <- parallel::mclapply(fams, mc.cores = 20,
    FUN = function(f) {### f <- fams[1]
      tmp_file <- sprintf(tmp_fstem, f)
      if(!file.exists(tmp_file) | force) {
        unlink(tmp_file)
      f_df <- fam_fill_prob %>%
        filter(family == f) %>%
        mutate(sd_vuln = ifelse(is.na(sd_vuln), 0, sd_vuln))
      
      message('Sampling ', iters, ' MC iterations for family ', f)
      
      mc_results_df <- f_df %>%
        rowwise() %>%
        mutate(v = list(rnorm(iters, mean = vuln, sd = sd_vuln))) %>%
        unnest(v) %>%
        mutate(v = case_when(v < 0 ~ 0, v > 1 ~ 1, TRUE ~ v)) %>%
        group_by(class, order, family, stressor, taxon) %>%
        summarize(mean_vuln = mean(v),
                  sd_vuln = sd(v),
                  # med_vuln = median(v),
                  n_spp_known = n_distinct(species)) %>%
        ungroup()

        write_csv(mc_results_df, tmp_file)
      }
    })
  
  family_fs <- list.files(here('tmp'), pattern = 'fam_fill_mc.+.csv',
                            full.names = TRUE)
  fam_list <- parallel::mclapply(family_fs, FUN = read_csv, mc.cores = 20)  
  fam_fill_prob_results <- fam_list %>%
    bind_rows() %>%
    left_join(fam_fill_qty)
  
  write_csv(fam_fill_prob_results, fam_fill_file)
}
```

combine all family-level gapfill values:
```{r}
fam_fill_prob_results <- read_csv(fam_fill_file)

fam_fill_totes <- bind_rows(fam_fill_det,
                            fam_fill_matchrank,
                            fam_fill_nondet_solo,
                            fam_fill_prob_results) %>%
  select(-n_spp) %>%
  mutate(gapfill = 'family') %>%
  left_join(count_df, by = c('family' = 'name', 'gapfill' = 'rank'))
```



#### Order level

``` {r order prob fill}
ord_fill_nondet <- match_vuln_df %>%
  # filter(genus == 'meridiastra') %>%
  group_by(class, order, stressor, taxon) %>%
  filter(sum(sd_vuln > 0, na.rm = TRUE) > 0) %>%
  ungroup()

ord_fill_matchrank <- ord_fill_nondet %>%
  group_by(class, order, stressor, taxon) %>%
  filter(all(match_rank %in% c('class', 'order'))) %>%
  summarize(mean_vuln = first(vuln), 
            # med_vuln = first(vuln), 
            sd_vuln = first(sd_vuln), 
            n_spp_known = n_distinct(species)) %>%
  ungroup()

ord_fill_nondet_solo <- ord_fill_nondet %>%
  filter(!order %in% ord_fill_matchrank$order) %>%
  group_by(class, order, stressor, taxon) %>%
  filter(n_distinct(vuln) == 1 & n_distinct(sd_vuln) == 1) %>%
  summarize(mean_vuln = first(vuln), 
            # med_vuln = first(vuln), 
            sd_vuln = first(sd_vuln), 
            n_spp_known = n_distinct(species)) %>%
  ungroup()
```

``` {r monte carlo for ord vuln dists}
ord_fill_file <- here('int', sprintf('gapfill_ord_prob_results_%s.csv', iters))

if(!file.exists(ord_fill_file) | reload) {
  ord_fill_prob <- ord_fill_nondet %>%
    anti_join(ord_fill_matchrank %>% select(order, stressor)) %>%
    anti_join(ord_fill_nondet_solo %>% select(order, stressor)) %>%
    group_by(class, order, stressor, taxon)
    
  ord_fill_qty <- ord_fill_prob %>%
    group_by(class, order, stressor, taxon) %>%
    summarize(n_spp = n(),
              n_prob = sum(sd_vuln > 0, na.rm = TRUE)) %>%
    filter(n_spp > 1) %>%
    ungroup()
  
  ords <- ord_fill_qty$order %>% unique() %>% sort()

  tmp_fstem <- here('tmp/ord_fill_mc_%s.csv')

  trash <- parallel::mclapply(ords, mc.cores = 20,
    FUN = function(o) {### o <- ords[1]
      tmp_file <- sprintf(tmp_fstem, o)
      if(!file.exists(tmp_file) | force) {
        unlink(tmp_file)
        o_df <- ord_fill_prob %>%
          filter(order == o) %>%
          mutate(sd_vuln = ifelse(is.na(sd_vuln), 0, sd_vuln))
        
        message('Sampling ', iters, ' MC iterations for order ', o)
    
        mc_results_df <- o_df %>%
          rowwise() %>%
          mutate(v = list(rnorm(iters, mean = vuln, sd = sd_vuln))) %>%
          unnest(v) %>%
          mutate(v = case_when(v < 0 ~ 0, v > 1 ~ 1, TRUE ~ v)) %>%
          group_by(class, order, stressor, taxon) %>%
          summarize(mean_vuln = mean(v),
                    sd_vuln = sd(v),
                    # med_vuln = median(v),
                    n_spp_known = n_distinct(species)) %>%
          ungroup()
  
          write_csv(mc_results_df, tmp_file)
      }
    })
  
  ord_fs <- list.files(here('tmp'), pattern = 'ord_fill_mc.+.csv',
                            full.names = TRUE)
  ord_list <- parallel::mclapply(ord_fs, FUN = read_csv, mc.cores = 20)
  
  ord_fill_prob_results <- ord_list %>%
    bind_rows() %>%
    left_join(ord_fill_qty)

  write_csv(ord_fill_prob_results, ord_fill_file)
}
```

combine all order-level gapfill values:
```{r}
ord_fill_prob_results <- read_csv(ord_fill_file)

ord_fill_totes <- bind_rows(ord_fill_det,
                            ord_fill_matchrank,
                            ord_fill_nondet_solo,
                            ord_fill_prob_results) %>%
  select(-n_spp) %>%
  mutate(gapfill = 'order') %>%
  left_join(count_df, by = c('order' = 'name', 'gapfill' = 'rank'))


```


#### Class level

``` {r class prob fill}
cls_fill_nondet <- match_vuln_df %>%
  # filter(genus == 'meridiastra') %>%
  group_by(class, stressor, taxon) %>%
  filter(sum(sd_vuln > 0, na.rm = TRUE) > 0) %>%
  ungroup()

cls_fill_matchrank <- cls_fill_nondet %>%
  group_by(class, stressor, taxon) %>%
  filter(all(match_rank %in% c('class'))) %>%
  summarize(mean_vuln = first(vuln), 
            # med_vuln = first(vuln), 
            sd_vuln = first(sd_vuln), 
            n_spp_known = n_distinct(species)) %>%
  ungroup()

cls_fill_nondet_solo <- cls_fill_nondet %>%
  filter(!class %in% cls_fill_matchrank$class) %>%
  group_by(class, stressor, taxon) %>%
  filter(n_distinct(vuln) == 1 & n_distinct(sd_vuln) == 1) %>%
  summarize(mean_vuln = first(vuln), 
            # med_vuln = first(vuln), 
            sd_vuln = first(sd_vuln), 
            n_spp_known = n_distinct(species)) %>%
  ungroup()
```

``` {r monte carlo for cls vuln dists}
cls_fill_file <- here('int', sprintf('gapfill_cls_prob_results_%s.csv', iters))

if(!file.exists(cls_fill_file) | reload) {

  cls_fill_prob <- cls_fill_nondet %>%
    anti_join(cls_fill_matchrank %>% select(class, stressor)) %>%
    anti_join(cls_fill_nondet_solo %>% select(class, stressor)) %>%
    group_by(class, stressor, taxon)
    
  cls_fill_qty <- cls_fill_prob %>%
    group_by(class, stressor, taxon) %>%
    summarize(n_spp = n(),
              n_prob = sum(sd_vuln > 0, na.rm = TRUE)) %>%
    filter(n_spp > 1) %>%
    ungroup()
  
  clss <- cls_fill_qty$class %>% unique() %>% sort()

  tmp_fstem <- here('tmp/cls_fill_mc_%s.csv')

  trash <- parallel::mclapply(clss, mc.cores = 20,
    FUN = function(c) {### c <- clss[1]
      tmp_file <- sprintf(tmp_fstem, c)
      if(!file.exists(tmp_file) | force) {
        unlink(tmp_file)
      c_df <- cls_fill_prob %>%
        filter(class == c) %>%
        mutate(sd_vuln = ifelse(is.na(sd_vuln), 0, sd_vuln))
      
      message('Sampling ', iters, ' MC iterations for class ', c)

      mc_results_df <- c_df %>%
        rowwise() %>%
        mutate(v = list(rnorm(iters, mean = vuln, sd = sd_vuln))) %>%
        unnest(v) %>%
        mutate(v = case_when(v < 0 ~ 0, v > 1 ~ 1, TRUE ~ v)) %>%
        group_by(class, stressor, taxon) %>%
        summarize(mean_vuln = mean(v),
                  sd_vuln = sd(v),
                  # med_vuln = median(v),
                  n_spp_known = n_distinct(species)) %>%
        ungroup()

        write_csv(mc_results_df, tmp_file)
      }
    })
  
  cls_fs <- list.files(here('tmp'), pattern = 'cls_fill_mc.+.csv',
                            full.names = TRUE)
  cls_list <- parallel::mclapply(cls_fs, FUN = read_csv, mc.cores = 20)  
  cls_fill_prob_results <- cls_list %>%
    bind_rows() %>%
    left_join(cls_fill_qty)
  
  write_csv(cls_fill_prob_results, cls_fill_file)
}
```

combine all class-level gapfill values:
```{r}
cls_fill_prob_results <- read_csv(cls_fill_file)

cls_fill_totes <- bind_rows(cls_fill_det,
                            cls_fill_matchrank,
                            cls_fill_nondet_solo,
                            cls_fill_prob_results) %>%
  select(-n_spp) %>%
  mutate(gapfill = 'class') %>%
  left_join(count_df, by = c('class' = 'name', 'gapfill' = 'rank'))
```


## Combine matched and gapfilled traits

Strip the higher ranks for file size; save out.
```{r combine gapfill value dataframes and save out}
vuln_all_spp <- match_vuln_df %>%
  mutate(gapfill = 'none') %>%
  bind_rows(gen_fill_totes, fam_fill_totes, ord_fill_totes, cls_fill_totes) %>%
  mutate(vuln = ifelse(is.na(vuln), mean_vuln, vuln),
         sd_vuln = ifelse(is.na(sd_vuln), 0, sd_vuln),
         n_prob = ifelse(is.na(n_prob), 0, n_prob)) %>%
  select(-mean_vuln, -phylum) %>%
  distinct()

### split with a taxon ID

vuln_tx <- vuln_all_spp %>%
  select(class:species, taxon, n_spp_known, n_prob, gapfill, match_rank) %>%
  distinct() %>%
  mutate(n_spp_known = ifelse(is.na(n_spp_known), 1, n_spp_known)) %>%
  arrange(class, order, family, genus, species) %>%
  mutate(tx_id = 1:n())

vuln_vals <- vuln_all_spp %>%
  left_join(vuln_tx %>% select(class:species, tx_id),
            by = c('class', 'order', 'family', 'genus', 'species')) %>%
  select(tx_id, stressor, vuln, sd_vuln) %>%
  mutate(across(where(is.numeric), ~ round(., 5)))
  
### write .csvs which can be joined using tx_id
write_csv(vuln_vals, file.path(dir_mazu, 'pre_gapfill/vuln_gapfill_values.csv'))
write_csv(vuln_tx,   file.path(dir_mazu, 'pre_gapfill/vuln_gapfill_taxa.csv'))
```

## Examine gapfill variability by stressor and taxon

### by standard deviation
```{r}
sd_compare <- vuln_all_spp %>%
  mutate(sd = ifelse(is.na(sd_vuln), 0, sd_vuln),
         pct_known = ifelse(gapfill == 'none', 1, n_spp_known / n_spp_total)) %>%
  group_by(gapfill, stressor, taxon) %>%
  summarize(mean_sd = mean(sd), 
            n_spp = n(),
            pct_known = mean(pct_known)) %>%
  mutate(gapfill = factor(gapfill, 
                          levels = c('none', 'genus', 'family', 'order', 'class'))) %>%
  ungroup()

sd_by_str <- sd_compare %>% 
  group_by(gapfill, stressor) %>%
  summarize(w_mean_sd = (sum(mean_sd * n_spp) / sum(n_spp)) %>% round(5)) %>%
  arrange(desc(gapfill), desc(w_mean_sd))

sd_by_taxon <- sd_compare %>% 
  group_by(gapfill, taxon) %>%
  summarize(w_mean_sd = (sum(mean_sd * n_spp) / sum(n_spp)) %>% round(5)) %>%
  arrange(desc(gapfill), desc(w_mean_sd))

pct_pop_by_taxon <- sd_compare %>%
  mutate(pct_to_fill = 1 - pct_known) %>%
  select(gapfill, taxon, n_spp, pct_to_fill) %>%
  distinct()
  
```

```{r}
ggplot(sd_by_str, aes(x = gapfill, y = w_mean_sd)) +
  geom_point() +
  facet_wrap(~stressor, scales = 'free_y') +
  theme(axis.text.x = element_text(angle = 90, vjust = .5)) +
  labs(title = 'std dev by stressor and gapfill level')
```

```{r}
ggplot(sd_by_taxon, aes(x = gapfill, y = w_mean_sd)) +
  geom_point() +
  facet_wrap(~taxon, scales = 'free_y') +
  theme(axis.text.x = element_text(angle = 90, vjust = .5)) +
  labs(title = 'std dev by taxon and gapfill level')
```

```{r}
ggplot(pct_pop_by_taxon, aes(x = gapfill, y = pct_to_fill)) +
  geom_point() +
  facet_wrap(~taxon) +
  theme(axis.text.x = element_text(angle = 90, vjust = .5)) +
  labs(title = 'Pct to fill by taxon and gapfill level')
```

## Calculate gapfill counts and taxon means/sds

First let's use the vulnerability gapfilling to fill in species up to class level (maximum) and write these out for posterity...

```{r apply upstreamed gapfill values to downstream spp}
vuln_vals <- read_csv(file.path(dir_mazu, 'pre_gapfill/vuln_gapfill_values.csv'))
vuln_tx   <- read_csv(file.path(dir_mazu, 'pre_gapfill/vuln_gapfill_taxa.csv'))
vuln_df <- vuln_tx %>%
  left_join(vuln_vals, by = 'tx_id') %>%
  select(-tx_id, -n_spp_known, -n_prob) %>%
  distinct()

vuln_direct_match <- vuln_df %>%
  filter(!is.na(match_rank))

gf_ranks <- c('species', 'genus', 'family', 'order', 'class')

gf_list <- vector('list', length = length(gf_ranks)) %>%
  setNames(gf_ranks)

gf_list[[1]] <- data.frame()

spp_done <- unique(vuln_direct_match$species)

for(i in 2:length(gf_ranks)) {
  ### i <- 3
  r <- gf_ranks[i]
  drop_ranks <- gf_ranks[c(1:(i-1))]
  rank_df <- vuln_df %>%
    filter(gapfill == r) %>%
    select(-all_of(drop_ranks)) %>%
    distinct()
  
  rank_gf_df <- spp_all_wide %>%
    filter(!species %in% spp_done) %>%
    inner_join(rank_df)
  
  spp_done <- c(spp_done, unique(rank_gf_df$species))
  
  gf_list[[i]] <- rank_gf_df
}

vuln_all_gf <- bind_rows(gf_list) %>%
  bind_rows(vuln_direct_match) %>%
  mutate(sd_vuln = ifelse(is.na(sd_vuln), 0, sd_vuln)) %>%
  select(-phylum)

vuln_gf_tx <- vuln_all_gf %>%
  select(class:species, taxon, gapfill, match_rank) %>%
  distinct() %>%
  arrange(species) %>%
  mutate(vuln_gf_id = 1:n())

vuln_gf_score <- vuln_all_gf %>%
  left_join(vuln_gf_tx %>% select(species, vuln_gf_id) %>% distinct(),
            by = 'species') %>%
  select(vuln_gf_id, stressor, vuln) %>%
  distinct() %>%
  mutate(vuln = round(vuln, 5)) %>%
  spread(stressor, vuln)

vuln_gf_sd <- vuln_all_gf %>%
  left_join(vuln_gf_tx %>% select(species, vuln_gf_id) %>% distinct(),
            by = 'species') %>%
  select(vuln_gf_id, stressor, sd_vuln) %>%
  distinct() %>%
  mutate(sd_vuln = round(sd_vuln, 5)) %>%
  spread(stressor, sd_vuln)

write_csv(vuln_gf_tx, file.path(dir_mazu, 'post_gapfill/vuln_gapfilled_all_tx.csv'))
write_csv(vuln_gf_score, file.path(dir_mazu, 'post_gapfill/vuln_gapfilled_all_score.csv'))
write_csv(vuln_gf_sd, file.path(dir_mazu, 'post_gapfill/vuln_gapfilled_all_sd.csv'))

```

... but for the purposes of the manuscript, let's do this again just to the family level:

### Outputs: Species matched or gapfilled to family level

```{r}

vuln_gf_fam <- vuln_all_gf %>%
  filter(gapfill %in% c('none', 'genus', 'family'))

vuln_gf_fam_tx <- vuln_gf_fam %>%
  select(class:species, taxon, gapfill, match_rank) %>%
  distinct() %>%
  arrange(species) %>%
  mutate(vuln_gf_id = 1:n())

vuln_gf_fam_score <- vuln_gf_fam %>%
  left_join(vuln_gf_fam_tx %>% select(species, vuln_gf_id) %>% distinct(),
            by = 'species') %>%
  select(vuln_gf_id, stressor, vuln) %>%
  distinct() %>%
  mutate(vuln = round(vuln, 5)) %>%
  spread(stressor, vuln)

vuln_gf_fam_sd <- vuln_gf_fam %>%
  left_join(vuln_gf_fam_tx %>% select(species, vuln_gf_id) %>% distinct(),
            by = 'species') %>%
  select(vuln_gf_id, stressor, sd_vuln) %>%
  distinct() %>%
  mutate(sd_vuln = round(sd_vuln, 5)) %>%
  spread(stressor, sd_vuln)

write_csv(vuln_gf_fam_tx, here('_output', 'vuln_gapfilled_tx.csv'))
write_csv(vuln_gf_fam_score, here('_output', 'vuln_gapfilled_score.csv'))
write_csv(vuln_gf_fam_sd, here('_output', 'vuln_gapfilled_sd.csv'))

```

### count of gapfill by taxon

Should be independent of stressor!

```{r count of gapfill status by taxon}
gf_count <- vuln_all_gf %>%
  group_by(taxon, gapfill, match_rank) %>%
  summarize(n_spp = n_distinct(species)) %>%
  ungroup() %>%
  mutate(val = case_when(gapfill == 'none' ~ paste0('match: ', match_rank),
                         TRUE ~ paste0('gapfill: ', gapfill))) %>%
  select(taxon, val, n_spp) %>%
  spread(val, n_spp)
knitr::kable(gf_count)
write_csv(gf_count, here('_output/gapfill_count.csv'))
```

### Breakdown by taxon

Using species gapfilled to the family level

```{r summarize stats by taxon}
tx_str_sum_outfile <- here('_output/taxon_str_vuln_summary.csv')

if(!file.exists(tx_str_sum_outfile) | reload) {

  taxa <- vuln_all_gf$taxon %>% unique() %>% sort()
  strs <- vuln_all_gf$stressor %>% unique() %>% sort()
  
  iters <- 10000
  
  tx_list <- vector('list', length = length(taxa)) %>%
    setNames(taxa)
  for(t in taxa) { ### t <- taxa[3]
    taxon_df <- vuln_all_gf %>%
      filter(gapfill %in% c('none', 'genus', 'family')) %>%
      filter(taxon == t)

    str_list <- parallel::mclapply(strs, mc.cores = 6,
      FUN = function(s) { ### s <- strs[1]
        taxon_str_df <- taxon_df %>%
          filter(stressor == s)
        message('Processing taxon ', t, ', ', s, ': nrows = ', nrow(taxon_str_df))
        n_known <- sum(taxon_str_df$gapfill == 'none')
        n_total <- n_distinct(taxon_str_df$species)
  
        mc_tx_str_df <- taxon_str_df %>%
          rowwise() %>%
          mutate(v = list(rnorm(iters, mean = vuln, sd = sd_vuln))) %>%
          unnest(v) %>%
          mutate(v = case_when(v < 0 ~ 0, v > 1 ~ 1, TRUE ~ v)) %>%
          group_by(taxon, stressor) %>%
          summarize(mean_vuln = mean(v) %>% round(5), 
                    sd_vuln = sd(v) %>% round(5),
                    mean_vuln_known  = sum(v * (gapfill == 'none')) / sum(gapfill == 'none') %>% 
                      round(5),
                    mean_vuln_filled = sum(v * (gapfill != 'none')) / sum(gapfill != 'none') %>%
                      round(5),
                    n_spp_known = n_known,
                    n_spp_total = n_total,
                    pct_spp_filled = round((n_total - n_known)/n_total * 100), 3)
        return(mc_tx_str_df)
      })
      
    tx_list[[t]] <- bind_rows(str_list)
  }
  
  tx_str_summary <- tx_list %>%
    bind_rows()
  write_csv(tx_str_summary, tx_str_sum_outfile)
}

  
  
tx_str_summary <- read_csv(tx_str_sum_outfile)
DT::datatable(tx_str_summary)

```


