---
title: "Gapfill taxa vulnerability"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

source('https://raw.githubusercontent.com/oharac/src/master/R/common.R')
library(taxize)

```

# Summary

Using taxonomic trees from WoRMS and the `taxize` package, we will try gapfilling vulnerabilities for non-scored species.

# Methods

* Load species vulnerabilities for known species.  
* Join the known species vulnerabilities to the expanded taxonomic list to get the full classification.
* For vulnerabilities calculated at a non-species level, we will calculate distribution parameters and then trickle those down to the species level.
    * For data given at the genus level (or above), this effectively automatically gapfills all species in the genus.
    * repeat for higher levels

## Assemble the taxonomic dataframe

Grab data from each rank (kingdom --> phylum, phylum --> class, class --> order, etc.) and assemble into a long dataframe.  Long format will be easier to match trait-scored species to, since all ranks will be in the "name" column.  But wide format will be easier for keeping track of the structure of each species' classification.

``` {r}
p_from_k <- read_csv(here('int/phylum_from_kingdom_worms.csv')) %>%
  filter(!is.na(id))
c_from_p <- read_csv(here('int/class_from_phylum_worms.csv')) %>%
  filter(!is.na(id))
o_from_c <- read_csv(here('int/order_from_class_worms.csv')) %>%
  filter(!is.na(id))
f_from_o <- read_csv(here('int/family_from_order_worms.csv')) %>%
  filter(!is.na(id))
g_from_f <- read_csv(here('int/genus_from_family_worms.csv')) %>%
  filter(!is.na(id))
s_from_g <- read_csv(here('int/species_from_genus_worms.csv')) %>%
  filter(!is.na(id))

rank_lvls <- c('kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species')

### create long df to match at any level
spp_df_long <- bind_rows(s_from_g, g_from_f, f_from_o, o_from_c, c_from_p, p_from_k) %>%
  mutate(rank = factor(rank, levels = rank_lvls)) %>%
  filter(!is.na(name))

full_class_file <- here('_data/spp_complete_classifications_worms.csv')
if(!file.exists(full_class_file)) {
  ### write this out; this can be used to recreate full classifications later
  write_csv(spp_df_long, full_class_file)
}

### create wide for complete classification for each species
spp_df_wide <- s_from_g %>%
  select(genus = parent, species = name) %>%
  left_join(g_from_f %>% select(family = parent, genus = name), 
            by = c('genus')) %>%
  left_join(f_from_o %>% select(order = parent, family = name), 
            by = c('family')) %>%
  left_join(o_from_c %>% select(class = parent, order = name), 
            by = c('order')) %>%
  left_join(c_from_p %>% select(phylum = parent, class = name), 
            by = c('class')) %>%
  left_join(p_from_k %>% select(kingdom = parent, phylum = name),
            by = c('phylum')) %>%
  select(kingdom, phylum, class, order, family, genus, species) %>%
  distinct()

### then make that long, but keeping structure for each species - maybe?
# spp_all_long <- spp_df_wide %>%
#   mutate(spp = species) %>%
#   gather(rank, name, kingdom:species) %>%
#   mutate(rank = factor(rank, levels = rank_lvls))
```

## Match species with known traits to most specific rank

Loading the traits data, and match to the long-format species classifications.  Then join these together sequentially by each level.

``` {r match up}
spp_traits  <- read_csv(here('_data/spp_traits_valid.csv'))
spp_gp_vuln <- read_csv(here('_output/spp_gp_vulnerability.csv'))

matched_df <- spp_df_long %>%
  inner_join(spp_traits, by = c('name' = 'spp_gp')) %>%
  # inner_join(spp_gp_vuln, by = c('name' = 'spp_gp')) %>%
  mutate(match = rank)
# matched_df$rank %>% unique() # species genus   family  class
```

``` {r identify unmatched species problems}
check_status <- function(check_ids) {
  check_ids <- check_ids[!is.na(check_ids)]
  n_chunks <- ceiling(length(check_ids) / 50)
  records_list <- vector('list', length = n_chunks)
  for(i in 1:n_chunks) {
    indices <- ((i-1)*50 + 1):min(i*50, length(check_ids))
    ids_chunk <- check_ids[indices]
    ids_param <- paste0('aphiaids[]=', ids_chunk, collapse = '&')
    records_url <- paste0('https://www.marinespecies.org/rest/AphiaRecordsByAphiaIDs?', ids_param)
    records_list[[i]] <- jsonlite::fromJSON(records_url) %>%
      select(id = AphiaID, sciname = scientificname, status) %>%
      distinct()
  }
  records_df <- records_list %>% 
    bind_rows()
  return(records_df)
}

unmatched_df <- spp_traits %>%
  filter(!spp_gp %in% matched_df$name) %>%
  select(taxon, spp_gp) %>%
  distinct()

check_class_list <- classification(unmatched_df$spp_gp, db = 'worms') %>%
  setNames(unmatched_df$spp_gp)
check_class_df <- check_class_list[!is.na(check_class_list)] %>%
  bind_rows(.id = 'spp_gp_orig') %>%
  mutate_if(is.character, tolower)
check_accepted_df <- check_status(check_class_df$id) %>%
  mutate(sciname = tolower(sciname))

unmatch_check_df <- unmatched_df %>%
  mutate(found = !is.na(check_class_list)) %>%
  left_join(check_class_df, by = c('spp_gp' = 'name')) %>%
  left_join(check_accepted_df, by = c('spp_gp' = 'sciname', 'id'))
```

### Unmatched spp groups with scored traits:

`r DT::datatable(unmatch_check_df)`

* Problems where a taxon is found, and accepted, may mean error in the `downstream` call.  Check the various `X_from_X.csv` dataframes to figure out where this taxon is being dropped.
* problems where a taxon is found, but not accepted (or not a main rank), may indicate species where an alternate name will fix the issue.
    * many of these have been identified and fixed in the original traits xlsx, with notes of expert-provided name
* problems where a taxon is not found may indicate typos, non-standard spellings, or species not yet in WoRMS
    * many of these have been identified and fixed in the original traits xlsx, with notes of expert-provided name

Specific problems:

* _Cellana tramoserica_ upstream has no "order" rank.
* _Ostrea angasi_ seems legit but not recognized in WoRMS.

## Expand classification for matched species

Identify the rank at which each spp group matched, and disambiguate spp gps that match at multiple ranks to identify the most specific rank. 
``` {r}
### Loop over matchable ranks to separate out the matched species by rank of match
match_ranks <- c('phylum', 'class', 'order', 'family', 'genus', 'species')
rank_partitions <- vector('list', length = length(match_ranks)) %>%
  setNames(match_ranks)
for(r in match_ranks) {
  rank_partitions[[r]] <- matched_df %>%
    filter(rank == r) %>%
    select(!!paste0('match_', r) := match, !!r := name, 
           stressor, vuln, contains('rescale'), taxon)
}

### Expand matched species to get full classification
match_exp <- spp_df_wide
for(r in match_ranks) {
  ### r <- 'class'
  tmp <- rank_partitions[[r]] %>%
    select(contains('match'), !!r) %>%
    distinct()
  match_exp <- match_exp %>%
    left_join(tmp, by = r)
}

### Disambiguate expanded matches to the most specific rank available
match_exp_dis <- match_exp %>%
  gather(key, match_rank, starts_with('match')) %>%
  ### filter unmatched species
  filter(!is.na(match_rank)) %>%
  ### keep the most specific match level
  mutate(match_rank = factor(match_rank, levels = rank_lvls)) %>%
  group_by(species) %>%
  filter(as.integer(match_rank) == max(as.integer(match_rank))) %>%
  ungroup() %>%
  select(-key) %>%
  distinct()

### Loop over the matchable ranks again, to dice the expanded match and
### join trait values by match rank.
match_vuln_list <- vector('list', length = length(match_ranks)) %>%
  setNames(match_ranks)
for(r in match_ranks) {
  ### r <- 'class'
  tmp_rank_part <- rank_partitions[[r]] %>%
    rename(match_rank := !!paste0('match_', r))
  match_vuln_list[[r]] <- match_exp_dis %>%
    filter(match_rank == r) %>%
    left_join(tmp_rank_part, by = c(r, 'match_rank'))
}
match_vuln_df <- bind_rows(match_vuln_list)
```

There are `r n_distinct(match_vuln_df$species)` (i.e., for taxa scored at the class level, how many species can be included, vs. for taxa at the species level):

``` {r}
knitr::kable(match_vuln_df %>% 
               group_by(match_rank) %>% 
               summarize(n_spp_matched = n_distinct(species)))
```

### Potential for gapfilling at each rank

For each rank, identify the taxa included in vulnerability data (e.g. which genera are included in our data, based on any match level).  Count the number of species known (from traits data), unknown but fillable (not specifically in traits data), and unknown and unfillable (no traits for that taxa).

``` {r}
rank_gapfill_potential <- vector('list', length = length(match_ranks) - 1) %>%
  setNames(match_ranks[-6])
for(r in match_ranks[-6]) { ### r <- 'class'
  rank_spp_known <- match_vuln_df %>%
    rename(tmp := !!r) %>%
    group_by(tmp) %>%
    summarize(n_spp_known = n_distinct(species)) %>%
    ungroup() %>%
    rename(!!r := tmp) 
  rank_spp_all <- spp_df_wide %>%
    rename(tmp := !!r) %>%
    group_by(tmp) %>%
    summarize(n_spp_all = n_distinct(species)) %>%
    ungroup() %>%
    rename(!!r := tmp) %>%
    left_join(rank_spp_known, by = r) %>%
    mutate(n_spp_fill = ifelse(is.na(n_spp_known), 0, n_spp_all - n_spp_known))
  rank_gapfill_potential[[r]] <- rank_spp_all %>% 
    summarize(n_spp_known = sum(n_spp_known, na.rm = TRUE),
              n_spp_fill = sum(n_spp_fill),
              n_spp_unknown = sum(n_spp_all) - n_spp_known - n_spp_fill,
              n_spp_all = sum(n_spp_all),
              rank = r)
}
knitr::kable(bind_rows(rank_gapfill_potential))
  
```

NOTE: the numbers increase as you go up in rank because there are many species (> 13,000!) classified into multiple higher-level ranks, so they get double counted.  

#### Here are the duplicates:

``` {r}
DT::datatable(x <- show_dupes(spp_df_wide %>% 
                          filter(!is.na(species)), 'species') %>% 
               arrange(species))
```

### create gapfill dataframes
``` {r}
gen_fill <- match_vuln_df %>%
  # filter(genus == 'meridiastra') %>%
  group_by(kingdom, phylum, class, order, family, genus, stressor, taxon) %>%
  summarize(n_known_spp = n_distinct(species),
            mean_vuln = mean(vuln),
            sd_vuln   = sd(vuln),
            med_vuln  = median(vuln),
            skew_vuln = psych::skew(vuln, type = 2),
            kurt_vuln = psych::kurtosi(vuln, type = 2),
            bimod_coef = mousetrap::bimodality_coefficient(vuln),
            gapfill = 'genus')
  
fam_fill <- match_vuln_df %>%
  group_by(kingdom, phylum, class, order, family, stressor, taxon) %>%
  summarize(n_known_spp = n_distinct(species),
            mean_vuln = mean(vuln),
            sd_vuln   = sd(vuln),
            med_vuln  = median(vuln),
            skew_vuln = moments::skewness(vuln),
            kurt_vuln = moments::kurtosis(vuln),
            bimod_coef = mousetrap::bimodality_coefficient(vuln),
            gapfill = 'family')

ord_fill <- match_vuln_df %>%
  group_by(kingdom, phylum, class, order, stressor, taxon) %>%
  summarize(n_known_spp = n_distinct(species),
            mean_vuln = mean(vuln),
            sd_vuln   = sd(vuln),
            med_vuln  = median(vuln),
            skew_vuln = moments::skewness(vuln),
            kurt_vuln = moments::kurtosis(vuln),
            bimod_coef = mousetrap::bimodality_coefficient(vuln),
            gapfill = 'order')
 
cls_fill <- match_vuln_df %>%
  group_by(kingdom, phylum, class, stressor, taxon) %>%
  summarize(n_known_spp = n_distinct(species),
            mean_vuln = mean(vuln),
            sd_vuln   = sd(vuln),
            med_vuln  = median(vuln),
            skew_vuln = moments::skewness(vuln),
            kurt_vuln = moments::kurtosis(vuln),
            bimod_coef = mousetrap::bimodality_coefficient(vuln),
            gapfill = 'class')
 
```
    
```{r gapfill}

gapfill_gen <- spp_df_wide %>%
  filter(!species %in% match_vuln_df$species) %>%
  left_join(gen_fill, by = c('kingdom', 'phylum', 'class', 'order', 'family', 'genus')) %>%
  filter(!is.na(gapfill))

# gapfill_gen$species %>% n_distinct() ### 7021

gapfill_fam <- spp_df_wide %>%
  filter(!species %in% match_vuln_df$species) %>%
  filter(!species %in% gapfill_gen$species) %>%
  left_join(fam_fill, by = c('kingdom', 'phylum', 'class', 'order', 'family')) %>%
  filter(!is.na(gapfill))
# gapfill_fam$species %>% n_distinct() 
### 28049 (family) + 7021 (genus) = 35070; should be 35709?

gapfill_ord <- spp_df_wide %>%
  filter(!species %in% match_vuln_df$species) %>%
  filter(!species %in% gapfill_gen$species) %>%
  filter(!species %in% gapfill_fam$species) %>%
  left_join(ord_fill, by = c('kingdom', 'phylum', 'class', 'order')) %>%
  filter(!is.na(gapfill))
# gapfill_ord$species %>% n_distinct() 
### 127759 (order) + 28049 + 7021 = 162869; should be 164880? or is that dupes?

gapfill_cls <- spp_df_wide %>%
  filter(!species %in% match_vuln_df$species) %>%
  filter(!species %in% gapfill_gen$species) %>%
  filter(!species %in% gapfill_fam$species) %>%
  filter(!species %in% gapfill_ord$species) %>%
  left_join(cls_fill, by = c('kingdom', 'phylum', 'class')) %>%
  filter(!is.na(gapfill))
# gapfill_cls$species %>% n_distinct() 
### 53063 (class) + 127759 + 28049 + 7021 = 215892 (vs 219356)

```

## Combine matched and gapfilled traits

Strip the higher ranks for file size; save out.
```{r}
vuln_all_spp <- match_vuln_df %>%
  mutate(gapfill = 'none') %>%
  bind_rows(gapfill_gen, gapfill_fam, gapfill_ord, gapfill_cls) %>%
  # select(-kingdom, -phylum, -class, -order, -family, -genus) %>%
  distinct()

### write big-ass .csv
write_csv(vuln_all_spp, '~/git-annex/spp_vuln/vuln_all_spp_gapfilled.csv')
```

### Examine unmatched classes and orders

These phyla, class, and orders are not able to be gapfilled by our current set of trait-scored species.
```{r}
unmatched <- spp_df_wide %>%
  filter(!species %in% vuln_all_spp$species) %>%
  group_by(kingdom, phylum, class, order) %>%
  summarize(n_spp = n_distinct(species)) %>%
  group_by(kingdom, phylum, class) %>%
  mutate(n_spp_class = sum(n_spp)) %>%
  group_by(kingdom, phylum) %>%
  mutate(n_spp_phylum = sum(n_spp))

DT::datatable(unmatched)
```

