---
title: "Match vulnerability scores to AquaMap and IUCN species"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

source('https://raw.githubusercontent.com/oharac/src/master/R/common.R')
library(taxize)
```

# Summary

From the calculated vulnerability for species groups across taxa, assign vulnerability scores to the species level for species in IUCN and AquaMaps.

# Methods


## Read in taxonomic info from IUCN and AquaMaps

___These are currently borrowed from other projects.  Would want to get fresh copies as part of this project.___  

For each of these datasets, we will attempt classification matching two ways, on both ends -

* unmodified dataset taxonomic ranks (e.g. what AM and IUCN say the species are, and what species experts say)
* `taxize`d versions of AquaMaps and IUCN as well as `taxize`d versions of the species expert classifications.

Standardizing the taxonomic classifications should improve matching, e.g. whether to use _elasmobranchii_ vs. _chondricthyes_.  For AquaMaps and IUCN, we do this by checking species names using `taxize::classification()` to get the full classification.  For species expert names, we may need to get more clever since we don't necessarily know what level is provided.

For those that don't match at the species level, we will go back to the genus, family, or order level to complete matches.

```{r}
### create a function to break up large species lists into chunks,
### saving to tmp, in case of breaks in internet connectivity
classify_chunks <- function(spp_df, flag, chunk_size = 1000) {
  ### spp_df is dataframe of sciname and id
  n_chunks <- ceiling(nrow(spp_df) / chunk_size)
  tmpstem <- here('tmp/taxize_results_%s_%s.csv')
  for(i in 1:n_chunks) { ### i <- 1
    message('Processing chunk ', i, ' of ', n_chunks)
    indices <- c(1 + chunk_size * (i - 1), min(nrow(spp_df), chunk_size * i))
    chunk_file <- sprintf(tmpstem, flag, paste0(indices, collapse = '_'))
    if(!file.exists(chunk_file)) {
      tmp_df <- spp_df[indices[1]:indices[2], ]
      
      chunk_results <- classification(tmp_df$sciname, db = 'ncbi') %>%
        setNames(tmp_df$id)
      
      chunk_check <- sapply(chunk_results, is.data.frame)
      error_results <- chunk_results[!chunk_check]
      if(length(error_results) > 0) message('chunk ', i, ' returned ', length(error_results),
                                            ' errors out of ', nrow(tmp_df))
      chunk_ok <- chunk_results[chunk_check]
      
      chunk_df <- bind_rows(chunk_ok, .id = sprintf('%s_sid', flag))
    
      write_csv(chunk_df, chunk_file)
    }
  }
  
  tmp_files <- list.files(here('tmp'), pattern = sprintf('taxize_results_%s', flag),
                          full.names = TRUE)
  
  results_all <- lapply(tmp_files, 
                        FUN = function(f) {
                          read_csv(f, col_types = cols(.default = 'c'))
                        }) %>%
    bind_rows()
  return(results_all)
}


ranks <- c('kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species')

```

```{r iucn_spp}
marine_spp <- read_csv(here('_raw_data/spp_marine_from_api_2020-1.csv'))
comp_spp <- read_csv(here('_raw_data/iucn_comp_assessed_2020-1.csv'))
iucn_spp <- read_csv(here('_raw_data/spp_info_from_api_2020-1.csv')) %>%
  filter(iucn_sid %in% marine_spp$iucn_sid) %>%
  filter(iucn_sid %in% comp_spp$iucn_sid)

raw_results_iucn <- iucn_spp %>%
  select(-category, species = sciname) %>%
  gather(rank, name, kingdom:species) %>%
  mutate(name = tolower(name),
         dataset = 'iucn_raw')

taxize_results_iucn_file <- here('int/taxize_results_iucn.csv')
if(!file.exists(taxize_results_iucn_file)) {
  iucn_taxize <- iucn_spp %>%
    select(id = iucn_sid, sciname) %>%
    distinct()
  
  spp_names <- iucn_taxize$sciname
    
  ### taxize::classification returns a list
  taxize_results <- classify_chunks(iucn_taxize, flag = 'iucn', chunk_size = 1000) %>%
    select(-id) %>%
    filter(rank %in% ranks) %>%
    mutate(iucn_sid = as.numeric(iucn_sid))
  
  write_csv(taxize_results, taxize_results_iucn_file)
}

taxize_results_iucn <- read_csv(taxize_results_iucn_file) %>%
  mutate(name = tolower(name),
         dataset = 'iucn_taxize')

iucn_spp_ranks <- raw_results_iucn %>%
  bind_rows(taxize_results_iucn) 

iucn_check <- iucn_spp_ranks %>%
  group_by(iucn_sid, rank) %>%
  mutate(no_diff = first(name) == last(name))
```

```{r am_spp}
am_spp <- read_csv(here('_raw_data/speciesoccursum.csv')) %>%
  janitor::clean_names() %>%
  mutate(sciname = paste(genus, species))

raw_results_am <- am_spp %>%
  select(am_sid = speciesid, kingdom:family, genus, species = sciname) %>%
  gather(rank, name, kingdom:species) %>%
  mutate(name = tolower(name),
         dataset = 'am_raw')

taxize_results_am_file <- here('int/taxize_results_am.csv')
if(!file.exists(taxize_results_am_file)) {
  am_taxize <- am_spp %>%
    select(id = speciesid, sciname) %>%
    distinct() %>%
    arrange(sciname)
  
  taxize_results <- classify_chunks(am_taxize, flag = 'am', chunk_size = 1000) %>%
    select(-id) %>%
    filter(rank %in% ranks)
  
  write_csv(taxize_results, taxize_results_am_file)
}

taxize_results_am <- read_csv(taxize_results_am_file) %>%
  mutate(name = tolower(name),
         dataset = 'am_taxize') 

am_spp_ranks <- raw_results_am %>%
  bind_rows(taxize_results_am) 

am_check <- am_spp_ranks %>%
  group_by(am_sid, rank) %>%
  mutate(no_diff = first(name) == last(name))
```

## Read in vulnerability and classify

These vulnerability scores are calculated in the `calculate_spp_vuln.Rmd` script.  Join these to the IUCN and AquaMaps species by various ranks.  Here we drop all the scores, just matching the names themselves.

```{r}
spp_vuln <- read_csv(here('_output/spp_gp_vulnerability.csv'))

spp_gps <- spp_vuln %>%
  select(taxon, spp_gp) %>%
  mutate(name = tolower(spp_gp)) %>%
  distinct()
```

### check vs AquaMaps

Note the number of matched species for each sheet from the traits workbook; note also the number of unmatched species groups from the traits workbook that are not matched to any species.

#### matched in AquaMaps

``` {r check against AquaMaps}

traits_vs_am <- am_spp_ranks %>%
  full_join(spp_gps, by = 'name')
            
traits_match_am <- traits_vs_am %>%
  filter(!is.na(am_sid)) %>%
  filter(!is.na(taxon)) %>%
  ### drop duplicates e.g. matched by both species name and family name
  mutate(rank = factor(rank, levels = ranks)) %>%
  group_by(am_sid) %>%
  filter(as.numeric(rank) == max(as.numeric(rank))) %>%
  select(am_sid, match_name = name, match_rank = rank, taxon, spp_gp, dataset) %>%
  group_by(am_sid) %>%
  filter(n() == 1 | dataset == 'am_raw') %>%
  ungroup() %>%
  left_join(am_spp %>%
              select(am_sid = speciesid, sciname, comname = f_bname), by = c('am_sid'))

traits_match_am_sum <- traits_match_am %>%
  group_by(taxon) %>%
  summarize(n_spp = n_distinct(am_sid),
            n_spp_match = sum(match_rank == 'species', na.rm = TRUE),
            n_genus_match = sum(match_rank == 'genus', na.rm = TRUE),
            n_fam_match = sum(match_rank == 'family', na.rm = TRUE),
            n_class_match = sum(match_rank == 'class', na.rm = TRUE))
knitr::kable(traits_match_am_sum)

n_tot_am <- traits_match_am$am_sid %>% n_distinct()
```

In total, there are `r n_tot_am` species matched in the AquaMaps dataset.

#### in spp traits, unmatched in AquaMaps

```{r}
traits_unmatch_am <- traits_vs_am %>%
  group_by(spp_gp) %>%
  filter(all(is.na(rank))) %>%
  ungroup() %>%
  select(taxon, spp_gp) %>%
  arrange(taxon, spp_gp)
  
traits_unmatched_am_sum <- traits_unmatch_am %>%
  group_by(taxon) %>%
  summarize(n_spp = n_distinct(spp_gp)) %>%
  ungroup() %>%
  arrange(desc(n_spp))
  
knitr::kable(traits_unmatched_am_sum)

DT::datatable(traits_unmatch_am)
```

#### in Aquamaps, unmatched in spp traits

```{r}
am_unmatch_traits <- am_spp %>%
  filter(!speciesid %in% traits_match_am$am_sid)
  
am_unmatch_traits_sum <- am_unmatch_traits %>%
  group_by(kingdom, phylum, class) %>%
  summarize(n_spp = n_distinct(speciesid)) %>%
  ungroup() %>%
  arrange(desc(n_spp))
  
DT::datatable(am_unmatch_traits_sum)

```


### check vs IUCN

Note the number of matched species for each sheet from the traits workbook; note also the number of unmatched species groups from the traits workbook that are not matched to any species.

#### matched in IUCN

``` {r check against IUCN}

traits_vs_iucn <- iucn_spp_ranks %>%
  full_join(spp_gps, by = 'name')

traits_match_iucn <- traits_vs_iucn %>%
  filter(!is.na(iucn_sid)) %>%
  filter(!is.na(taxon)) %>%
  ### drop duplicates e.g. matched by both species name and family name
  mutate(rank = factor(rank, levels = ranks)) %>%
  group_by(iucn_sid) %>%
  filter(as.numeric(rank) == max(as.numeric(rank))) %>%
  select(iucn_sid, matched_name = name, matched_rank = rank, taxon, spp_gp, dataset) %>%
  group_by(iucn_sid) %>%
  filter(n() == 1 | dataset == 'iucn_raw') %>%
  ungroup() %>%
  left_join(iucn_spp %>%
              select(iucn_sid, sciname), by = c('iucn_sid'))

traits_match_iucn_sum <- traits_match_iucn %>%
  group_by(taxon) %>%
  summarize(n_spp = n_distinct(iucn_sid),
            n_spp_match = sum(matched_rank == 'species', na.rm = TRUE),
            n_genus_match = sum(matched_rank == 'genus', na.rm = TRUE),
            n_fam_match = sum(matched_rank == 'family', na.rm = TRUE),
            n_class_match = sum(matched_rank == 'class', na.rm = TRUE))
knitr::kable(traits_match_iucn_sum)

n_tot_iucn <- traits_match_iucn$iucn_sid %>% n_distinct()

n_tot_am_iucn <- traits_match_iucn %>% 
  select(iucn_sid, sciname) %>%
  full_join(traits_match_am %>% select(am_sid, sciname),
            by = 'sciname') %>%
  .$sciname %>% n_distinct()
```

In total, there are `r n_tot_iucn` species matched in the IUCN dataset.

Combined with AquaMaps, we can assign traits to `r n_tot_am_iucn` distinct species.

#### in spp traits, unmatched in IUCN

```{r}
traits_unmatch_iucn <- traits_vs_iucn %>%
  group_by(spp_gp) %>%
  filter(all(is.na(rank))) %>%
  ungroup() %>%
  select(taxon, spp_gp) %>%
  arrange(taxon, spp_gp)

traits_unmatched_iucn_sum <- traits_unmatch_iucn %>%
  group_by(taxon) %>%
  summarize(n_spp = n_distinct(spp_gp)) %>%
  ungroup() %>%
  arrange(desc(n_spp))
  
knitr::kable(traits_unmatched_iucn_sum)

DT::datatable(traits_unmatch_iucn)
```

#### in IUCN, unmatched in spp traits

```{r}
iucn_unmatch_traits <- iucn_spp %>%
  filter(!iucn_sid %in% traits_match_iucn$iucn_sid)
  
iucn_unmatch_traits_sum <- iucn_unmatch_traits %>%
  group_by(kingdom, phylum, class) %>%
  summarize(n_spp = n_distinct(iucn_sid)) %>%
  ungroup() %>%
  mutate(kingdom = tolower(kingdom), phylum = tolower(phylum), class = tolower(class)) %>%
  arrange(desc(n_spp))
  
DT::datatable(iucn_unmatch_traits_sum)

```

#### How many species from experts are not matched in either data set?
```{r}

traits_unmatch_all <- bind_rows(traits_unmatch_am, traits_unmatch_iucn) %>%
  distinct()

knitr::kable(traits_unmatch_all %>% group_by(taxon) %>% summarize(n_spp_gps = n_distinct(spp_gp)))

DT::datatable(traits_unmatch_all)

```

