---
title: "Process species trait spreadsheets"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

source('https://raw.githubusercontent.com/oharac/src/master/R/common.R')

```

# Summary

Read in Excel spreadsheets of taxonomic traits filled in by taxon experts.  Process into a long/tidy format with checks on validity of category values.  Identify categories that were assigned non-valid values.

# Data

`_raw_data/all_taxa_trait_data.xlsx' is the raw spreadsheet prepared by Nathalie Butt from the various submissions of the taxa-group experts.  Basic format:

Columns `category`, `sub-category`, and `category units` are standard.  Additional columns correspond to species or species groups, with perhaps additional idiosyncratic columns populated with totals, notes, comments, etc.

# Methods

Set up path and sheetnames

```{r}
raw_file <- here('_raw_data/all_taxa_trait_data.xlsx')

sheetnames <- readxl::excel_sheets(raw_file)
sheetnames <- sheetnames[sheetnames != 'habitat_list'] ### drop extraneous sheet
```

Process Nat's key

```{r}
catvals_df_raw <- readxl::read_excel(here('excel_files/cat_val_key_tidyish.xlsx')) %>%
  janitor::clean_names() %>%
  select(category, trait, cat_vals) %>%
  filter(!(is.na(category) & is.na(trait))) %>%
  fill(category, .direction = 'down') %>%
  mutate(category = tolower(category), trait = tolower(trait))

catvals_df_prehabs <- catvals_df_raw %>%
  mutate(cat_vals = str_split(cat_vals, pattern = ';')) %>%
  unnest(cat_vals) %>%
  ### trim whitespace, replace the temporary slash fixes
  mutate(cat_vals = str_trim(cat_vals)) %>%
           ### undo the temp slash fix
  filter(!is.na(cat_vals)) %>%
  filter(cat_vals != '')

### Read in the first column of habitats from the list.  Paste together with
### semicolon separator.  Set to lower case.
habs <- readxl::read_excel(here('excel_files/hab_list.xlsx')) %>%
  janitor::clean_names() %>%
  .$habitat_types %>%
  tolower() %>%
  paste(collapse = ';')
    
### Separate out habitat rows, attach valid habitats, bind back to original.
catvals_hab <- catvals_df_prehabs %>%
  filter(str_detect(cat_vals, 'habitat')) %>%
  mutate(cat_vals = habs,
         cat_vals = str_split(habs, pattern = ';')) %>%
  unnest(cat_vals)
  

catvals_df_valid <- catvals_df_prehabs %>%
  filter(!str_detect(cat_vals, 'habitat')) %>%
  bind_rows(catvals_hab)

write_csv(catvals_df_valid, 'int/category_vals_valid.csv')
```

Read in Excel sheets one at a time, convert to long format, bind into a single dataframe with minimal processing.

First, check headers to make sure there's not taxonomic information in multiple rows.  The first row of each sheet should be blank, as most sheets have a space before the first category ("Movement").  Even without this space, "Movement" should not have any values of its own, so still blank.

```{r}
check_headers <- function(f, s) {
  df <- readxl::read_excel(path = f, sheet = s, n_max = 1) %>%
    gather(hdg, val, -c(1:3)) %>%
    select(hdg, val) %>%
    mutate(sheet = s)
  return(df)
}

hdr_check <- lapply(sheetnames, FUN = function(s) check_headers(raw_file, s)) %>%
  bind_rows() %>%
  filter(!is.na(val))

probs <- hdr_check$sheet %>% unique()
```

The following sheets seem to have additional information with headers: `r probs`.

* Cephalopods have order info in first line (which becomes header) then species info in second line (which should be captured as the taxonomic group).
* Reef fishes have a species count in the first line (which becomes header) then genus/species in the second line (which should be captured as the taxonomic group).
* Corals have genus in top line, and then spp count in second line.  Not a problem; this will be dropped.
* Echinoderms have species names in top row (which becomes header, OK) then some limited info on order in second row (which will be dropped).

``` {r}
process_sheet <- function(f, s) {
  ### f <- raw_file; s <- sheetnames[1]
  df_raw <- readxl::read_excel(path = f, sheet = s)
  
  ### read in to get "valid" categories
  categories <- read_csv('int/category_vals_valid.csv') %>%
    .$category %>% unique()
  
  if(s %in% c('cephalopods', 'reef_other_fish')) {
    ### problematic spp sheets - taxonomic info in second line of csv
    spp_names <- df_raw[1, ]
    spp_names[1:3] <- c('category', 'sub_category', 'category units')
    df_raw <- df_raw %>%
      setNames(spp_names)
  }
    
  df <- df_raw %>%
    gather(spp_gp, trait_value, -c(1:3)) %>%
    janitor::clean_names() %>%
    select(-category_units)
  
  df_cleaned <- df %>%
    mutate(trait = ifelse(is.na(sub_category), category, sub_category),
           trait = tolower(trait),
           category = tolower(category),
           category = ifelse(category == 'light dependence', 'specialisation', category),
             ### fill in below the "physiological tolerance breadths" category
           category = ifelse(!category %in% categories, NA, category)) %>%
    fill(category, .direction = 'down') %>%
    select(category, trait, spp_gp, trait_value) %>%
    filter(!is.na(trait)) %>%
      ### drops rows with no trait listed
    filter(trait != category) %>%
      ### drops category headings in the traits column
    mutate(sheet = s)
  
  return(df_cleaned)
}

raw_data_df <- lapply(sheetnames, FUN = function(s) process_sheet(raw_file, s)) %>%
  bind_rows()
```

Check raw data against valid category values.

* Set all values to lower case to avoid case sensitivity.
* replace "n/a" with "na"
* Ditch numeric commas.
* Split trait values on semicolons to separate multiple cell values; then unnest and str_trim.

```{r}
clean_up_mess <- function(df) {
  df %>%
    mutate(trait_val_clean = str_trim(trait_val_clean)) %>%
    filter(trait_val_clean != '') %>%
    select(category, trait, trait_value, trait_val_clean, spp_gp, sheet) %>%
    distinct()
}

clean_trait <- function(x) {
  str_replace_all(x, '[^0-9a-zA-Z<>;]', '') %>% tolower()
}
```

### clean up troublesome traits

```{r}
catvals_df_clean <- read_csv('int/category_vals_valid.csv') %>%
  mutate(cat_val_clean = str_replace_all(tolower(cat_vals), '[^0-9a-z<>;]', ''))

### focus on zone traits
zone_vals <- catvals_df_valid %>%
  filter(trait == 'zone') %>%
  .$cat_vals %>% paste0(collapse = '|')

spp_data_zones <- raw_data_df %>%
  filter(trait == 'zone') %>%
  ### fix misspelling:
  mutate(trait_value = str_replace_all(trait_value, 'demerssal', 'demersal')) %>%
  mutate(tmp = str_extract_all(tolower(trait_value), zone_vals)) %>%
  unnest(tmp) %>%
  mutate(trait_val_clean = clean_trait(tmp)) %>%
  clean_up_mess()
  
### focus on mobility traits
mob_vals <- catvals_df_valid %>%
  filter(trait == 'adult mobility') %>%
  .$cat_vals %>% paste0(collapse = '|')
# "sessile|nearly sessile/sedentary|passive|vertical migrator|mobile resident|horizontal migrator|nomadic"
  
spp_data_mobility <- raw_data_df %>%
  filter(trait == 'adult mobility') %>%
  mutate(tmp = str_replace_all(tolower(trait_value), '[^a-z ]+', ';')) %>%
  ### split and unnest, trim and clean:
  mutate(tmp = str_split(tmp, ';')) %>%
  unnest(tmp) %>%
  ### clean up some inconsistencies
  mutate(tmp = str_replace_all(tmp, 'horiz[a-z]+', 'horizontal'),
         tmp = str_replace_all(tmp, 'vertic[a-z]+', 'vertical'),
         tmp = str_replace_all(tmp, 'migrat[a-z]+', 'migrator'),
         tmp = str_replace_all(tmp, 'residen[a-z]+', 'resident'),
         tmp = str_replace_all(tmp, 'sedentary', 'nearly sessile/sedentary')) %>%
  # mutate(tmp = ifelse(str_detect(tmp, mob_vals),
  #                                 str_extract_all(tmp, mob_vals),
  #                                 tmp)) %>%
  mutate(tmp = str_extract_all(tmp, mob_vals)) %>%
  unnest(tmp) %>%
  mutate(trait_val_clean = clean_trait(tmp)) %>%
  clean_up_mess()

### focus on depth traits
depth_vals <- catvals_df_valid %>%
  filter(trait == 'depth (min/max)') %>%
  .$cat_vals %>% paste0(collapse = '|')

spp_data_depth <- raw_data_df %>%
  filter(trait == 'depth (min/max)') %>%
  mutate(tmp = str_replace_all(tolower(trait_value), '[^a-z0-9 ]+', ';')) %>%
  mutate(tmp = str_extract_all(tmp, depth_vals)) %>%
  unnest(tmp) %>%
  mutate(trait_val_clean = clean_trait(tmp)) %>%
  clean_up_mess()

### focus on thermal sensitivity traits
### ocean warming values are 5°C-10-15-20-25-30°C
spp_data_thermal1 <- raw_data_df %>%
  filter(str_detect(trait, 'thermal - sensitivity to ocean warming')) %>%
  rowwise() %>%
  mutate(trait_num = str_extract_all(trait_value, '[0-9]+') %>% unlist() %>% as.integer() %>% max(),
         trait_num = min(floor(trait_num / 5) * 5, 30),
         trait_num = ifelse(is.infinite(trait_num), NA, trait_num)) %>%
  ungroup() %>%
  mutate(tmp = ifelse(!is.na(trait_num), paste0(trait_num, 'c'),
                                tolower(trait_value))) %>%
  mutate(trait_val_clean = ifelse(str_detect(tmp, 'broad|low sensitivity'), 
                                  '30c', tmp)) %>%
  clean_up_mess()

# spp_data_thermal1$trait_val_clean %>% unique()

### heat spike values are yes/no
spp_data_thermal2 <- raw_data_df %>%
  filter(str_detect(trait, 'thermal - sensitivity to heat spikes')) %>%
  mutate(tmp = tolower(trait_value),
         tmp = case_when(str_detect(tmp, 'broad') ~ 'no',
                         str_detect(tmp, 'narrow|sensitive') ~ 'yes',
                         str_detect(tmp, 'can recover') ~ 'no',
                         TRUE ~ tmp)) %>%
  mutate(trait_val_clean = str_replace_all(tmp, '[^a-z0-9]+', '_')) %>%
  clean_up_mess()

# spp_data_thermal2$trait_val_clean %>% unique()

### focus on pH traits
ph_vals <- catvals_df_valid %>%
  filter(trait == 'ph') %>%
  .$cat_vals %>% paste0(collapse = '|')

### ph values are <7.4|7.5-7.7|7.8-8.2
spp_data_ph <- raw_data_df %>%
  filter(trait == 'ph') %>%
  ### fix a typo:
  mutate(trait_value = str_replace(trait_value, '(?<=\\d),(?=\\d)', '.')) %>%
  ### get mean - find into which category the mean falls
  rowwise() %>%
  mutate(trait_mean = str_extract_all(trait_value, '[0-9.]+') %>% unlist() %>% as.numeric() %>% mean(),
         trait_mean = ifelse(is.infinite(trait_mean), NA, trait_mean)) %>%
  ungroup() %>%
  mutate(tmp = case_when(is.na(trait_mean) ~ tolower(trait_value),
                         trait_mean < 7.5 ~ '<7.4',
                         trait_mean < 7.8 ~ '7.5-7.7',
                         TRUE ~ '7.8-8.2')) %>%
  mutate(tmp = case_when(str_detect(tmp, 'broad|not sensitive') ~ '<7.4', 
                         str_detect(tmp, 'narrow')              ~ '7.8-8.2',
                                    TRUE                        ~ tmp)) %>%
  mutate(trait_val_clean = clean_trait(tmp)) %>%
  clean_up_mess()

```

### combine into a relatively clean df

``` {r}

spp_data_clean <- raw_data_df %>%
  filter(!trait %in% c('zone', 'adult mobility', 'depth (min/max)', 'ph') &
           !str_detect(trait, 'thermal - sensitivity'))%>%
  mutate(trait_val_clean = clean_trait(trait_value)) %>%
  ### split and unnest, trim and clean:
  mutate(trait_val_clean = str_split(trait_val_clean, ';')) %>%
  unnest(trait_val_clean) %>%
  clean_up_mess() %>%
  bind_rows(spp_data_zones) %>%
  bind_rows(spp_data_mobility) %>%
  bind_rows(spp_data_depth) %>%
  bind_rows(spp_data_thermal1) %>%
  bind_rows(spp_data_thermal2) %>%
  bind_rows(spp_data_ph) %>%
  mutate(trait_val_clean = clean_trait(trait_val_clean)) ### just to make sure

spp_validcheck <- spp_data_clean %>%
  left_join(catvals_df_clean %>% mutate(valid = TRUE), 
            by = c('category', 'trait', 
                   'trait_val_clean' = 'cat_val_clean')) %>%
  filter(!is.na(spp_gp))

spp_invalid <- spp_validcheck %>%
  filter(is.na(valid)) %>%
  filter(trait_val_clean != 'na') %>%
  select(-valid)
write_csv(spp_invalid, 'invalid_spp_category_values.csv')

spp_valid <- spp_validcheck %>%
  filter(valid) %>%
  select(category, trait, trait_value, trait_val_clean, spp_gp, sheet) %>%
  mutate(category = str_replace_all(category, '[^A-Za-z0-9]+', '_') %>% tolower(),
         category = str_replace_all(category, '^_|_$', ''),
         trait    = str_replace_all(trait, '[^A-Za-z0-9]+', '_') %>% tolower(),
         trait    = str_replace_all(trait, '^_|_$', ''))

# spp_valid$spp_gp %>% n_distinct()

write_csv(spp_valid, '_data/spp_traits_valid.csv')
```

There are `r spp_valid$spp_gp %>% n_distinct()` distinct species/species groups accounted for with at least some valid data.

#### Trouble spots - count of spp with mismatched trait values by trait

``` {r}
knitr::kable(spp_invalid %>% 
               group_by(trait) %>% 
               summarize(n_mismatches = n()) %>% 
               arrange(desc(n_mismatches)))
```

