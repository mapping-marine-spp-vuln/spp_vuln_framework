---
title: "Check downfilled numbers vs Nat's numbers"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

library(oharac) ### remotes::install_github('oharac/oharac')
oharac::setup()
source(here('common_fxns.R'))
options(dplyr.summarise.inform = FALSE) 

```

# Summary

Compare Nat's species counts to those included in the downfill operation - i.e., matches at higher-order ranks.

# Methods

Read in the downfilled species list (`gapfill == 'none'` indicates properly downfilled).  Nat's sheet is not easily parsed unfortunately, so will generate outputs one taxon at a time.

```{r}
spp_downfill <- read_csv(here('int/spp_match_downfill.csv'))

taxa_in_code <- spp_downfill$taxon %>% unique() %>% sort()

xlsx_f <- here('_raw_data/xlsx/species_numbers.xlsx')
spp_count_shts <- readxl::excel_sheets(xlsx_f)
taxa_in_xlsx <- spp_count_shts[spp_count_shts != 'summary'] %>% sort()

if(length(taxa_in_xlsx[!taxa_in_xlsx %in% taxa_in_code]) > 0) {
  stop('Non-matches in taxon names')
}
```

## Raw count by taxon

```{r}

count_df <- data.frame()

for(t in taxa_in_code) {
  ### t <- taxa_in_code[1]
  n_in_code <- spp_downfill %>%
    filter(taxon == t) %>%
    count() %>%
    .$n
  
  n_in_xlsx <- readxl::read_excel(xlsx_f, sheet = t) %>%
    summarize(n = sum(n_spp, na.rm = TRUE)) %>%
    .$n
  
  count_df <- count_df %>%
    bind_rows(data.frame(taxon = t, n_in_code, n_in_xlsx))
}

count_df <- count_df %>%
  mutate(diff = n_in_code - n_in_xlsx,
         pct_diff = 100 * round(diff / n_in_xlsx, 3))
knitr::kable(count_df %>% arrange(desc(abs(pct_diff))))
```


The big differences for fish, crustacea/arthropods, and molluscs are due to accounting for representative species, as well as the expanded fish list.  Other reasonable differences may be due to differences of taxonomic opinion about inclusion of species in various taxa (e.g., synonyms, subpopulations, etc).

## Check specific taxa

### Seabirds

These should be pretty spot-on, since our numbers here select only seabirds.  Which species/taxa are still missing?

```{r}
seabird_list <- readxl::read_excel(here('_raw_data/xlsx/species_numbers.xlsx'),
                                   sheet = 'seabirds', skip = 1) %>%
  janitor::clean_names() %>%
  select(spp = scientific_name_fixed) %>%
  filter(!is.na(spp)) %>%
  mutate(spp = tolower(spp)) %>%
  .$spp

birds_from_code <- spp_downfill %>%
  filter(taxon == 'seabirds') %>%
  mutate(seabird = (species %in% seabird_list)) %>%
  select(family, genus, species, seabird) %>%
  distinct() %>%
  mutate(code = 1)

birds_from_xlsx <- readxl::read_excel(xlsx_f, sheet = 'seabirds', skip = 1) %>%
  janitor::clean_names() %>%
  select(family = family_fixed, species = scientific_name_fixed, common_name) %>%
  mutate(family = tolower(family),
         species = tolower(species) %>% str_trim()) %>%
  mutate(genus = str_remove(species, ' .+')) %>%
  mutate(xlsx = 1)

n_birds_xlsx <- birds_from_xlsx$species %>% n_distinct()
n_birds_code <- birds_from_code$species %>% n_distinct()

combo <- birds_from_code %>%
  full_join(birds_from_xlsx, by = c('family', 'genus', 'species'))

mismatch <- combo %>%
  filter(is.na(code) | is.na(xlsx))
match <- combo %>%
  filter(code == 1 & xlsx == 1)

match_by_fam <- combo %>%
  group_by(family) %>%
  summarize(n_match = sum(code == 1 & xlsx == 1, na.rm = TRUE),
            n_mismatch = sum(is.na(code) | is.na(xlsx)))

knitr::kable(match_by_fam)

fam_from_xlsx <- readxl::read_excel(xlsx_f, sheet = 'seabirds') %>%
  select(1, n_spp) %>%
  filter(!is.na(n_spp)) %>%
  distinct()

knitr::kable(fam_from_xlsx)

```

Matches for (counts in code/mismatch vs total in xlsx):

* Alcidae (24/1 vs 24)
* Diomedeidae (21/2 vs 22)
* Fregatidae/Phaethontidae (8/0 vs 8)
* Sphenicidae (18/1 vs. 18)
* Sulidae (10/0 vs. 10)
* Anatidae, Gaviidae, Podicipedidae (19/2, 5/0, 4/0 vs. 30) - total (28/4 vs. 30)
* Oceanitidae, Hydrobatidae (0/0, 23/1) - total (23/1)
* Procellariidae (90/0, vs 18+38) - resulting in 34 extras?
* Pelecanidae, Phalacrocoracidae (3/0, 29/1 - total 32/1 vs. 33) - note also pelecanoididae 4/0
* Phalaropodidae (2/0 vs. 2) - listed on XLSX as Scolopacidae
* Laridae (80/8 vs. 87)

Notes: fixes have been implemented in the XSLX spreadsheet and code above for improved matching.

```{r}
worms <- assemble_worms(aspect = 'wide', seabirds = FALSE) %>%
  filter(class == 'aves') %>%
  mutate(seabird = (species %in% seabird_list))
sum(worms$seabird)
```

## Final counts


```{r}
gapfilled_taxa  <- read_csv(here('_output/vuln_gapfilled_tx.csv'))
gapfilled_score <- read_csv(here('_output/vuln_gapfilled_score.csv')) %>%
  gather(str, vuln, -vuln_gf_id) %>%
  full_join(gapfilled_taxa, by = 'vuln_gf_id') %>%
  filter(!is.na(vuln))
nspp_gf <- gapfilled_score$species %>% n_distinct()

gf_df_all <- read_csv(here('_output/gapfill_count.csv')) %>%
  gather(level, n, -taxon) %>%
  mutate(type = str_extract(level, '.+(?=:)'),
         level = str_extract(level, '(?<= ).+'),
         level = factor(level, levels = c('species', 'genus', 'family', 'order', 'class'))) %>%
  arrange(taxon, type, level)

gf_df_long <- gf_df_all %>%
  filter(!(level %in% c('order', 'class') & type == 'gapfill'))

gf_df_wide <- gf_df_all %>% 
  spread(level, n)

n_match <- gf_df_long %>%
  filter(type == 'match') %>%
  summarize(n = sum(n, na.rm = TRUE)) %>%
  .$n %>% as.integer()

n_gf <- gf_df_long %>%
  filter(type == 'gapfill') %>%
  summarize(n = sum(n, na.rm = TRUE)) %>%
  .$n %>% as.integer()

n_gf <- gf_df_long %>%
  filter(type == 'gapfill') %>%
  summarize(n = sum(n, na.rm = TRUE)) %>%
  .$n %>% as.integer()

n_gf_order <- gf_df_all %>%
  filter(type == 'gapfill' & level == 'order') %>%
  summarize(n = sum(n, na.rm = TRUE)) %>%
  .$n %>% as.integer()
  
n_gf_class <- gf_df_all %>%
  filter(type == 'gapfill' & level == 'class') %>%
  summarize(n = sum(n, na.rm = TRUE)) %>%
  .$n %>% as.integer()
  

```

### match counts per taxon and rank

`r knitr::kable(gf_df_wide %>% filter(type == 'match') %>% select(-type))`

### gapfill counts per taxon and rank

`r knitr::kable(gf_df_wide %>% filter(type == 'gapfill') %>% select(-type, -species))`

### Totals

The total species count for direct matches (matches driven by traits provided by experts at a representative rank (species, genus, family, order, class) plus those driven by denoting certain species to be representive of a higher rank (e.g., several species that together are representative of an entire family): `r n_match` species. 

The total species count for gapfilled matches (at genus and family ranks only) is
`r n_gf` species.

The total for species representation including both direct match (downfill) and imputed values (upstream/downstream gapfill) is
`r n_match + n_gf` species.

Allowing imputation of species vulnerability from order level would result in an additional `r n_gf_order` species, for total gapfill of `r n_gf + n_gf_order` and grand total of `r n_match + n_gf + n_gf_order` species.

Allowing imputation from class level would result in an additional `r n_gf_class` species, for total gapfill of `r n_gf + n_gf_order +n_gf_class` and grand total of `r n_match + n_gf + n_gf_order +n_gf_class` species.
